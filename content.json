{"meta":{"title":"Silence","subtitle":null,"description":"个人微博","author":"Silence","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"重拾JavaScript(this)","slug":"JavaScript/this","date":"2019-08-22T03:41:52.000Z","updated":"2019-08-22T03:52:09.000Z","comments":true,"path":"2019/08/22/JavaScript/this/","link":"","permalink":"http://yoursite.com/2019/08/22/JavaScript/this/","excerpt":"","text":"一、调用位置 在理解 this 的绑定过程之前,首先要理解调用位置:调用位置就是函数在代码中被调用的位置(而不是声明的位置)。 二、诀窍规则 函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。 var bar = new foo() 函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话,this绑定的是 指定的对象。 var bar = foo.call(obj2) 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话,this绑定的是那个上 下文对象。 var bar = obj1.foo() 如果都不是的话,使用默认绑定。如果在严格模式下,就绑定到undefined,否则绑定到 全局对象。 var bar = foo()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript基础","slug":"JavaScript基础","permalink":"http://yoursite.com/tags/JavaScript基础/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"重拾JavaScript(Object对象)","slug":"JavaScript/对象","date":"2019-08-22T01:38:37.000Z","updated":"2019-08-22T03:32:33.000Z","comments":true,"path":"2019/08/22/JavaScript/对象/","link":"","permalink":"http://yoursite.com/2019/08/22/JavaScript/对象/","excerpt":"","text":"一、概念 对象是一个抽象的概念, 可以将其简单的理解为: 数据集或功能集（对象就是可以拥有属性和方法的一个集合）. 二、语法 对象可以通过两种形式定义,声明(文字)形式和构造形式. 声明式var myObj = { key: value}; 构造式var myObj = new Object(); myObj.key = value; 三、JavaScript内置对象 String Number Boolean Object Function Array Date RegExp Error 四、内容 .操作符(属性访问) [] 操作符(键访问) 123var myObject = &#123; a: 2&#125;;myObject.a; // 2 .操作符(属性访问)myObject[&quot;a&quot;]; // 2 [] 操作符(键访问) （1）、可计算属性名1234567var prefix = &quot;foo&quot;;var myObject = &#123;[prefix + &quot;bar&quot;]:&quot;hello&quot;,[prefix + &quot;baz&quot;]: &quot;world&quot;&#125;;myObject[&quot;foobar&quot;]; // hellomyObject[&quot;foobaz&quot;]; // world （2）、属性和方法123456function Obj() &#123; this.name = &apos;sy&apos;; //属性 this.say = function() &#123; //方法 console.log(&apos;my name is &apos; + this.name) &#125;&#125; （3）、属性描述符 Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性） 语法Object.getOwnPropertyDescriptor(obj, prop) 参数obj需要查找的目标对象 prop目标对象内属性名称 返回值 如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。 实例 12345678910var myObject = &#123; a:2&#125;;Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );// &#123;// value: 2,// writable: true,// enumerable: true,// con gurable: true // &#125;Object.getOwnPropertyDescriptor( myObject, &quot;b&quot; );//undefined。 Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。 语法Object.defineProperties(obj, props) 参数obj在其上定义或修改属性的对象。 props 要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。描述符具有以下键： configurable true 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。 默认为 false enumerable true 当且仅当在枚举相应对象上的属性时该属性显现。 默认为 false value 与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。 默认为 undefined. writable true当且仅当与该属性相关联的值可以用assignment operator改变时。 默认为 false get 作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。 默认为 undefined set 作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。 默认为 undefined 返回值 传递给函数的对象。 举例 123456789101. 在创建普通属性时属性描述符会使用默认值,我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。var myObject = &#123;&#125;;Object.defineProperty( myObject, &quot;a&quot;, &#123; value: 2, writable: true, configurable: true, enumerable: true&#125;);myObject.a; // 2 1234567891011122. Writablewritable 决定是否可以修改属性的值。var myObject = &#123;&#125;;Object.defineProperty( myObject, &quot;a&quot;, &#123; value: 2, writable: false, // 不可写! configurable: true, enumerable: true&#125;);myObject.a = 3;myObject.a; // 2使用严格模式会TypeError （TypeError 错误表示我们无法修改一个不可写的属性。） 12345678910111213141516171819202122232425262728293031323334353637383940413. Configurable只要属性是可配置的,就可以使用 defineProperty(..) 方法来修改属性描述符:var myObject = &#123; a:2&#125;;myObject.a = 3;myObject.a; // 3Object.defineProperty( myObject, &quot;a&quot;, &#123; value: 4, writable: true, configurable: false, // 不可配置! enumerable: true &#125;);myObject.a; // 4myObject.a = 5;myObject.a; // 5Object.defineProperty( myObject, &quot;a&quot;, &#123; value: 6, writable: true, configurable: true, enumerable: true&#125;); // TypeError- 最后一个 defineProperty(..) 会产生一个 TypeError 错误,不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错。注意:如你所见,把 configurable 修改成 false 是单向操作,无法撤销!- 要注意有一个小小的例外:即便属性是 configurable:false,我们还是可以 把 writable 的状态由 true 改为 false,但是无法由 false 改为 true。var myObject = &#123; a:2&#125;; myObject.a; // 2 delete myObject.a; myObject.a; // undefinedObject.defineProperty( myObject, &quot;a&quot;, &#123; value: 2, writable: true, configurable: false, enumerable: true&#125; );myObject.a; // 2 delete myObject.a; myObject.a; // 2因为不可配置 所以delete（静默）失败。 1234. Enumerable是否可以对象的属性枚举比如说 for..in 循环。如果把 enumerable 设置成 false,这个属性就不会出现在枚举中 123455. Getter和Setter（对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。）当你给一个属性定义 getter、setter 或者两者都有时,这个属性会被定义为“访问描述 符”(和“数据描述符”相对)。对于访问描述符来说,JavaScript 会忽略它们的 value 和 writable 特性,取而代之的是关心 set 和 get(还有 configurable 和 enumerable)特性。 （4）、不变性 对象常量12345678var myObject = &#123;&#125;;Object.defineProperty( myObject, &quot;FAVORITE_NUMBER&quot;, &#123; value: 42, writable: false, configurable: false &#125;);- 禁止扩展 (禁止一个对象添加新属性并且保留已有属性) var myObject = { a:2};Object.preventExtensions( myObject );myObject.b = 3;myObject.b; // undefined1234- 密封 Object.seal(..) 会创建一个“密封”的对象,这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。所以,密封之后不仅不能添加新属性,也不能重新配置或者删除任何现有属性(虽然可以 修改属性的值)。- 冻结 Object.freeze(..) 会创建一个冻结对象,这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false,这样就无法修改它们 的值。 （5）、存在性 in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中 hasOwnProperty(..) 只会检查属性是否在 myObject 对象中,不会检查 [[Prototype]] 链 propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中(而不是在原型链 上)并且满足 enumerable:true。 Object.keys(..) 会返回一个数组,包含所有可枚举属性,Object.getOwnPropertyNames(..) 会返回一个数组,包含所有属性,无论它们是否可枚举。 for..in 循环可以用来遍历对象的可枚举属性列表(包括 [[Prototype]] 链)。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript基础","slug":"JavaScript基础","permalink":"http://yoursite.com/tags/JavaScript基础/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}]},{"title":"排序算法","slug":"排序算法和搜索算法/排序算法","date":"2019-06-21T02:14:57.000Z","updated":"2019-06-28T03:11:10.000Z","comments":true,"path":"2019/06/21/排序算法和搜索算法/排序算法/","link":"","permalink":"http://yoursite.com/2019/06/21/排序算法和搜索算法/排序算法/","excerpt":"","text":"一、冒泡排序123456789101112131415161718192021222324252627282930313233343536373839404142434445写法一function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;写法二const Compare = &#123; LESS_THAN: -1, BIGGER_THAN: 1, EQUALS: 0&#125;;function defaultCompare(a, b) &#123; if (a === b) &#123; return Compare.EQUALS; &#125; return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;&#125;function swap(array, a, b) &#123; /* const temp = array[a]; array[a] = array[b]; array[b] = temp; */ [array[a], array[b]] = [array[b], array[a]];&#125;function bubbleSort(array, compareFn = defaultCompare) &#123; const &#123; length &#125; = array; for (let i = 0; i &lt; length; i++) &#123; for (let j = 0; j &lt; length - 1; j++) &#123; if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) &#123; swap(array, j, j + 1); &#125; &#125; &#125; return array;&#125; 二、选择排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455方法一function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; if(i !== minIndex) &#123; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125; return arr;&#125;写法二const Compare = &#123; LESS_THAN: -1, BIGGER_THAN: 1, EQUALS: 0&#125;;function defaultCompare(a, b) &#123; if (a === b) &#123; return Compare.EQUALS; &#125; return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;&#125;function swap(array, a, b) &#123; /* const temp = array[a]; array[a] = array[b]; array[b] = temp; */ [array[a], array[b]] = [array[b], array[a]];&#125;function selectionSort = (array, compareFn = defaultCompare) =&gt; &#123; const &#123; length &#125; = array; let indexMin; for (let i = 0; i &lt; length - 1; i++) &#123; indexMin = i; for (let j = i; j &lt; length; j++) &#123; if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) &#123; indexMin = j; &#125; &#125; if (i !== indexMin) &#123; swap(array, i, indexMin); &#125; &#125; return array;&#125;; 三、插入排序1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex+1] = arr[preIndex]; preIndex--; &#125; arr[preIndex+1] = current; &#125; return arr;&#125; 四、归并排序12345678910111213141516171819202122232425262728293031function mergeSort(arr) &#123; //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"JavaScript字典和散列表","slug":"DataStructure/JavaScript字典和散列表","date":"2019-06-18T09:50:19.000Z","updated":"2019-06-18T10:03:09.000Z","comments":true,"path":"2019/06/18/DataStructure/JavaScript字典和散列表/","link":"","permalink":"http://yoursite.com/2019/06/18/DataStructure/JavaScript字典和散列表/","excerpt":"","text":"一、概念 字典存储的是【键，值】其中键名是用来查询特定的元素的（不重复元素）字典也称作映射、符号表、关联数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function defaultToString(item) &#123; if (item === null) &#123; return &apos;NULL&apos;; &#125; if (item === undefined) &#123; return &apos;UNDEFINED&apos;; &#125; if (typeof item === &apos;string&apos; || item instanceof String) &#123; return `$&#123;item&#125;`; &#125; return item.toString();&#125;class Dictionary &#123; constructor(toStrFn = defaultToString) &#123; this.toStrFn = toStrFn; this.table = &#123;&#125;; &#125; set(key, value) &#123; if (key != null &amp;&amp; value != null) &#123; const tableKey = this.toStrFn(key); this.table[tableKey] = new ValuePair(key, value); return true; &#125; return false; &#125; get(key) &#123; const valuePair = this.table[this.toStrFn(key)]; return valuePair == null ? undefined : valuePair.value; &#125; hasKey(key) &#123; return this.table[this.toStrFn(key)] != null; &#125; remove(key) &#123; if (this.hasKey(key)) &#123; delete this.table[this.toStrFn(key)]; return true; &#125; return false; &#125; values() &#123; return this.keyValues().map(valuePair =&gt; valuePair.value); &#125; keys() &#123; return this.keyValues().map(valuePair =&gt; valuePair.key); &#125; keyValues() &#123; return Object.values(this.table); &#125; forEach(callbackFn) &#123; const valuePairs = this.keyValues(); for (let i = 0; i &lt; valuePairs.length; i++) &#123; const result = callbackFn(valuePairs[i].key, valuePairs[i].value); if (result === false) &#123; break; &#125; &#125; &#125; isEmpty() &#123; return this.size() === 0; &#125; size() &#123; return Object.keys(this.table).length; &#125; clear() &#123; this.table = &#123;&#125;; &#125; toString() &#123; if (this.isEmpty()) &#123; return &apos;&apos;; &#125; const valuePairs = this.keyValues(); let objString = `$&#123;valuePairs[0].toString()&#125;`; for (let i = 1; i &lt; valuePairs.length; i++) &#123; objString = `$&#123;objString&#125;,$&#123;valuePairs[i].toString()&#125;`; &#125; return objString; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"JavaScript集合(Set)","slug":"DataStructure/JavaScript集合(Set)","date":"2019-06-18T09:14:52.000Z","updated":"2019-06-18T09:48:11.000Z","comments":true,"path":"2019/06/18/DataStructure/JavaScript集合(Set)/","link":"","permalink":"http://yoursite.com/2019/06/18/DataStructure/JavaScript集合(Set)/","excerpt":"","text":"一、概念 集合：集合是由一组无序且唯一的项组成的。 二、知识碎点 in运算符 验证给定的元素是否在对象上的属性。(原型链上有都会返回true) Object.prototype.hasOwnProperty.call(Obj,element)。 (只是当前对象，不含原型链上的属性和方法) 三、具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104class Set &#123; constructor() &#123; this.items = &#123;&#125;; &#125; add(element) &#123; if (!this.has(element)) &#123; this.items[element] = element; return true; &#125; return false; &#125; delete(element) &#123; if (this.has(element)) &#123; delete this.items[element]; return true; &#125; return false; &#125; has(element) &#123; return Object.prototype.hasOwnProperty.call(this.items, element); &#125; values() &#123; return Object.values(this.items); &#125; 并集 union(otherSet) &#123; const unionSet = new Set(); this.values().forEach(value =&gt; unionSet.add(value)); otherSet.values().forEach(value =&gt; unionSet.add(value)); return unionSet; &#125; 交集 intersection(otherSet) &#123; const intersectionSet = new Set(); const values = this.values(); const otherValues = otherSet.values(); let biggerSet = values; let smallerSet = otherValues; if (otherValues.length - values.length &gt; 0) &#123; biggerSet = otherValues; smallerSet = values; &#125; smallerSet.forEach(value =&gt; &#123; if (biggerSet.includes(value)) &#123; intersectionSet.add(value); &#125; &#125;); return intersectionSet; &#125; 差集 difference(otherSet) &#123; const differenceSet = new Set(); this.values().forEach(value =&gt; &#123; if (!otherSet.has(value)) &#123; differenceSet.add(value); &#125; &#125;); return differenceSet; &#125; 子集 isSubsetOf(otherSet) &#123; if (this.size() &gt; otherSet.size()) &#123; return false; &#125; let isSubset = true; this.values().every(value =&gt; &#123; if (!otherSet.has(value)) &#123; isSubset = false; return false; &#125; return true; &#125;); return isSubset; &#125; isEmpty() &#123; return this.size() === 0; &#125; size() &#123; return Object.keys(this.items).length; &#125; clear() &#123; this.items = &#123;&#125;; &#125; toString() &#123; if (this.isEmpty()) &#123; return &apos;&apos;; &#125; const values = this.values(); let objString = `$&#123;values[0]&#125;`; for (let i = 1; i &lt; values.length; i++) &#123; objString = `$&#123;objString&#125;,$&#123;values[i].toString()&#125;`; &#125; return objString; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"小程序云开发","slug":"小程序/小程序云开发","date":"2019-06-17T03:28:16.000Z","updated":"2019-06-17T06:56:03.000Z","comments":true,"path":"2019/06/17/小程序/小程序云开发/","link":"","permalink":"http://yoursite.com/2019/06/17/小程序/小程序云开发/","excerpt":"","text":"云待办 数据设计vant weapp 引入 miniprogram 执行 npm i vant-weapp -S --production 右上角点击详情勾选使用npm模块 菜单栏点击工具=&gt;构建npm","categories":[{"name":"小程序云开发","slug":"小程序云开发","permalink":"http://yoursite.com/categories/小程序云开发/"}],"tags":[],"keywords":[{"name":"小程序云开发","slug":"小程序云开发","permalink":"http://yoursite.com/categories/小程序云开发/"}]},{"title":"JavaScript双端队列(Queue)","slug":"DataStructure/JavaScript双端队列(Queue)","date":"2019-06-14T08:23:14.000Z","updated":"2019-06-14T08:45:04.000Z","comments":true,"path":"2019/06/14/DataStructure/JavaScript双端队列(Queue)/","link":"","permalink":"http://yoursite.com/2019/06/14/DataStructure/JavaScript双端队列(Queue)/","excerpt":"","text":"一、概念 是一种允许我们同时从前端和后端添加和移除元素的特殊队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Deque &#123; constructor() &#123; this.count = 0; this.lowestCount = 0; this.items = &#123;&#125;; &#125; addFront(element) &#123; if (this.isEmpty()) &#123; this.addBack(element); &#125; else if (this.lowestCount &gt; 0) &#123; this.lowestCount--; this.items[this.lowestCount] = element; &#125; else &#123; for (let i = this.count; i &gt; 0; i--) &#123; this.items[i] = this.items[i - 1]; &#125; this.count++; this.items[0] = element; &#125; &#125; addBack(element) &#123; this.items[this.count] = element; this.count++; &#125; removeFront() &#123; if (this.isEmpty()) &#123; return undefined; &#125; const result = this.items[this.lowestCount]; delete this.items[this.lowestCount]; this.lowestCount++; return result; &#125; removeBack() &#123; if (this.isEmpty()) &#123; return undefined; &#125; this.count--; const result = this.items[this.count]; delete this.items[this.count]; return result; &#125; peekFront() &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items[this.lowestCount]; &#125; peekBack() &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items[this.count - 1]; &#125; isEmpty() &#123; return this.size() === 0; &#125; clear() &#123; this.items = &#123;&#125;; this.count = 0; this.lowestCount = 0; &#125; size() &#123; return this.count - this.lowestCount; &#125; toString() &#123; if (this.isEmpty()) &#123; return &apos;&apos;; &#125; let objString = `$&#123;this.items[this.lowestCount]&#125;`; for (let i = this.lowestCount + 1; i &lt; this.count; i++) &#123; objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`; &#125; return objString; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"JavaScript队列(Queue)","slug":"DataStructure/JavaScript队列(Queue)","date":"2019-06-14T07:26:34.000Z","updated":"2019-06-14T07:38:18.000Z","comments":true,"path":"2019/06/14/DataStructure/JavaScript队列(Queue)/","link":"","permalink":"http://yoursite.com/2019/06/14/DataStructure/JavaScript队列(Queue)/","excerpt":"","text":"一、概念 栈：先进先出。队列尾部添加新元素，并从顶部移除元素。新添加的元素必须排在队列的末尾。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Queue &#123; constructor() &#123; this.count = 0; this.lowestCount = 0; this.items = &#123;&#125;; &#125; enqueue(element) &#123; this.items[this.count] = element; this.count++; &#125; dequeue() &#123; if (this.isEmpty()) &#123; return undefined; &#125; const result = this.items[this.lowestCount]; delete this.items[this.lowestCount]; this.lowestCount++; return result; &#125; peek() &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items[this.lowestCount]; &#125; isEmpty() &#123; return this.size() === 0; &#125; clear() &#123; this.items = &#123;&#125;; this.count = 0; this.lowestCount = 0; &#125; size() &#123; return this.count - this.lowestCount; &#125; toString() &#123; if (this.isEmpty()) &#123; return &apos;&apos;; &#125; let objString = `$&#123;this.items[this.lowestCount]&#125;`; for (let i = this.lowestCount + 1; i &lt; this.count; i++) &#123; objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`; &#125; return objString; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"JavaScript栈(Stack)","slug":"DataStructure/JavaScript栈(Stack)","date":"2019-06-14T06:24:30.000Z","updated":"2019-06-14T07:34:25.000Z","comments":true,"path":"2019/06/14/DataStructure/JavaScript栈(Stack)/","link":"","permalink":"http://yoursite.com/2019/06/14/DataStructure/JavaScript栈(Stack)/","excerpt":"","text":"一、概念 栈：后进先出。新添加和待删除的元素都保存在栈的同一端，称作栈顶，另一端叫栈底，在栈里，新元素都靠近栈顶，旧元素靠近栈底。 二、实现方式1.基于数组方式实现的栈12345678910111213141516171819202122232425262728293031323334353637class StackArray &#123; constructor() &#123; this.items = []; &#125; push(element) &#123; this.items.push(element); &#125; pop() &#123; return this.items.pop(); &#125; peek() &#123; return this.items[this.items.length - 1]; &#125; isEmpty() &#123; return this.items.length === 0; &#125; size() &#123; return this.items.length; &#125; clear() &#123; this.items = []; &#125; toArray() &#123; return this.items; &#125; toString() &#123; return this.items.toString(); &#125;&#125; 2.基于对象方式实现的栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Stack &#123; constructor() &#123; this.count = 0; this.items = &#123;&#125;; &#125; push(element) &#123; this.items[this.count] = element; this.count++; &#125; pop() &#123; if (this.isEmpty()) &#123; return undefined; &#125; this.count--; const result = this.items[this.count]; delete this.items[this.count]; return result; &#125; peek() &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items[this.count - 1]; &#125; isEmpty() &#123; return this.count === 0; &#125; size() &#123; return this.count; &#125; clear() &#123; /* while (!this.isEmpty()) &#123; this.pop(); &#125; */ this.items = &#123;&#125;; this.count = 0; &#125; toString() &#123; if (this.isEmpty()) &#123; return &apos;&apos;; &#125; let objString = `$&#123;this.items[0]&#125;`; for (let i = 1; i &lt; this.count; i++) &#123; objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`; &#125; return objString; &#125;&#125; 三、保护数据结构内部元素 因为我们能使用JavaScript中in操作符(for..in)、Object.keys()和Object.getOwnPropertyNames()来获取对象里面的属性和方法，我们把自己的属性和方法设置为私有，那么我们要了解一门新的基础数据类型Symbol。先了解基础数据类型Symbol 使用Symbol定义的属性名不能被外部(for..in)、Object.keys()和Object.getOwnPropertyNames()访问，但是会被Object.getOwnPropertySymbols(Stack)访问。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const _items = Symbol(&apos;stackItems&apos;);class Stack &#123; constructor() &#123; this[_items] = []; &#125; push(element) &#123; this[_items].push(element); &#125; pop() &#123; return this[_items].pop(); &#125; peek() &#123; return this[_items][this[_items].length - 1]; &#125; isEmpty() &#123; return this[_items].length === 0; &#125; size() &#123; return this[_items].length; &#125; clear() &#123; this[_items] = []; &#125; print() &#123; console.log(this.toString()); &#125; toString() &#123; return this[_items].toString(); &#125;&#125;const stack = new Stack();const objectSymbols = Object.getOwnPropertySymbols(stack);console.log(objectSymbols.length); // 1console.log(objectSymbols); // [Symbol()]console.log(objectSymbols[0]); // Symbol()stack[objectSymbols[0]].push(1);stack.print(); // 5, 8, 1 使用WeakMap实现私有 缺点：采用这种方式代码可读性差，扩展该类时无法继承私有属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const _items = new WeakMap();const _count = new WeakMap();class Stack &#123; constructor() &#123; _count.set(this, 0); _items.set(this, &#123;&#125;); &#125; push(element) &#123; const items = _items.get(this); const count = _count.get(this); items[count] = element; _count.set(this, count + 1); &#125; pop() &#123; if (this.isEmpty()) &#123; return undefined; &#125; const items = _items.get(this); let count = _count.get(this); count--; _count.set(this, count); const result = items[count]; delete items[count]; return result; &#125; peek() &#123; if (this.isEmpty()) &#123; return undefined; &#125; const items = _items.get(this); const count = _count.get(this); return items[count - 1]; &#125; isEmpty() &#123; return _count.get(this) === 0; &#125; size() &#123; return _count.get(this); &#125; clear() &#123; /* while (!this.isEmpty()) &#123; this.pop(); &#125; */ _count.set(this, 0); _items.set(this, &#123;&#125;); &#125; toString() &#123; if (this.isEmpty()) &#123; return &apos;&apos;; &#125; const items = _items.get(this); const count = _count.get(this); let objString = `$&#123;items[0]&#125;`; for (let i = 1; i &lt; count; i++) &#123; objString = `$&#123;objString&#125;,$&#123;items[i]&#125;`; &#125; return objString; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"Vuex","slug":"Vue/vuex","date":"2019-06-06T09:35:49.000Z","updated":"2019-06-06T10:00:07.000Z","comments":true,"path":"2019/06/06/Vue/vuex/","link":"","permalink":"http://yoursite.com/2019/06/06/Vue/vuex/","excerpt":"","text":"1.mapState 获取state值 定义方式 import {mapState} from ‘vuex’ 使用方式 对象 123computed: mapState(&#123; count: state=&gt;state.count&#125;) 数组 1computed: mapState([count]) 2.getter 获取state的值（过滤） 定义方式 写在vuex里面 12345getters: &#123; state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) 过滤数据 &#125;&#125; 方法有两个参数（state,getters）getters（可以认为是 store 的计算属性）state是状态值 getter也可以返回一个函数 getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。 1234getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id)&#125;store.getters.getTodoById(2) 使用方式 import { mapGetters } from &apos;vuex&apos; 数组 使用对象展开运算符将 getter 混入 computed 对象中 123456computed: &#123; ...mapGetters([ &apos;doneTodosCount&apos;, &apos;anotherGetter&apos; ])&#125; 对象 （对象的好处是getter 属性另取一个名字) 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` 123mapGetters(&#123; doneCount: &apos;doneTodosCount&apos;&#125;) 3.Mutation（更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。同步）定义 // mutation-types.js export const SOME_MUTATION = &apos;SOME_MUTATION&apos; // store.js import Vuex from &apos;vuex&apos; import { SOME_MUTATION } from &apos;./mutation-types&apos; 123456789const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state,params) &#123; // mutate state &#125; &#125;&#125;) 使用 import { mapMutations } from &apos;vuex&apos; export default { // ... 12345678910111213methods: &#123; 数组 ...mapMutations([ &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)` // `mapMutations` 也支持载荷： &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)` ]), 对象 ...mapMutations(&#123; add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)` &#125;)&#125; 4.Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 定义 12345actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125;&#125; Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。 12345actions: &#123; increment (&#123;commit&#125;) &#123; commit(&apos;increment&apos;) &#125;&#125; 使用 // 以载荷形式分发 12345678910111213141516171819202122232425store.dispatch(&apos;incrementAsync&apos;, &#123; amount: 10&#125;)// 以对象形式分发store.dispatch(&#123; type: &apos;incrementAsync&apos;, amount: 10&#125;)actions: &#123; checkout (&#123; commit, state &#125;, products) &#123; // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () =&gt; commit(types.CHECKOUT_SUCCESS), // 失败操作 () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems) ) &#125;&#125; 使用 123456789101112131415import &#123; mapActions &#125; from &apos;vuex&apos;export default &#123;// ...methods: &#123; ...mapActions([ &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` // `mapActions` 也支持载荷： &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)` ]), ...mapActions(&#123; add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` &#125;)&#125; 定义 actions结束后触发函数 12345678910actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit(&apos;someMutation&apos;) resolve() &#125;, 1000) &#125;) &#125;&#125; 使用 123store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123;// ...&#125;) 在另外一个 action 中也可以： 12345678actions: &#123;// ...actionB (&#123; dispatch, commit &#125;) &#123; return dispatch(&apos;actionA&apos;).then(() =&gt; &#123; commit(&apos;someOtherMutation&apos;) &#125;) &#125;&#125; 最后，如果我们利用 async / await，我们可以如下组合 action： // 假设 getData() 和 getOtherData() 返回的是 Promise 123456789actions: &#123; async actionA (&#123; commit &#125;) &#123; commit(&apos;gotData&apos;, await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch(&apos;actionA&apos;) // 等待 actionA 完成 commit(&apos;gotOtherData&apos;, await getOtherData()) &#125;&#125; 5.模块12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;modules: &#123; a: moduleA, b: moduleB&#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vuex","slug":"Vuex","permalink":"http://yoursite.com/tags/Vuex/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Mongodb","slug":"Mongodb/Mongodb","date":"2019-06-06T08:32:58.000Z","updated":"2019-06-06T08:33:33.000Z","comments":true,"path":"2019/06/06/Mongodb/Mongodb/","link":"","permalink":"http://yoursite.com/2019/06/06/Mongodb/Mongodb/","excerpt":"","text":"一、 基础Shell命令。 show dbs :显示已有数据库，如果你刚安装好，会默认有local、admin(config)，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。 use admin： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。9（如果当前数据库名字不存在则建立该名字的数据库，但是在没有集合前，它还是默认为空。） show collections: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。 db:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。 二、 数据操作基础命令： use db（建立数据库）：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。 db.集合.insert( ):新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。Demo：db.user.insert({“name”:”jspang”}) db.集合.find( ):查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。Demo：db.user.find() db.集合.findOne( ):查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。 db.集合.update({查询},{修改}):修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。 1db.jspang.update(&#123;&quot;name&quot;:&quot;jspang&quot;&#125;,&#123;&quot;name&quot;:&quot;jspang&quot;,&quot;age&quot;:&quot;32&quot;&#125;) db.集合.remove(条件)：删除文件数据，注意的是要跟一个条件。Demo:db.user.remove({“name”:”jspang”}) db.集合.drop( ):删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。 db.dropDatabase( ):删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。三、在操作数据库时要注意两个能力： 第一个是快速存储能力。 第二个是方便迅速查询能力。四、 批量插入12345db.test.insert([ &#123;&quot;_id&quot;:1&#125;, &#123;&quot;_id&quot;:2&#125;, &#123;&quot;_id&quot;:3&#125;]) 注意一次插入不要超过48M，向.zip和大图片什么的尽量用静态存储，MongoDB存储静态路径就好，这也算是一个规则。 数据插入选用批量插入性能远远大于循环插入。五、 update修改器 修改非嵌入文档1dbd .workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;&quot;$set&quot;:&#123;sex:2,age:21&#125;&#125;) 修改嵌入文档 1db.workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;&quot;$set&quot;:&#123;&quot;skill.skillThree&quot;:&apos;word&apos;&#125;&#125;) $unset用于将key删除 1db.workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;$unset:&#123;&quot;age&quot;:&apos;&apos;&#125;&#125;) $inc对数字进行计算 1db.workmate.update(&#123;&quot;name&quot;:&quot;MinJie&quot;&#125;,&#123;$inc:&#123;&quot;age&quot;:-2&#125;&#125;) multi选项 1db.workmate.update(&#123;&#125;,&#123;$set:&#123;interset:[]&#125;&#125;) 只改变了第一个数据1db.workmate.update(&#123;&#125;,&#123;$set:&#123;interset:[]&#125;&#125;,&#123;multi:true&#125;) 每个数据都发生了改变，multi是有ture和false两个值，true代表全部修改，false代表只修改一个（默认值） upsert选项1db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$set:&#123;age:20&#125;&#125;,&#123;upsert:true&#125;) upsert是在找不到值的情况下，直接插入这条数据。upsert也有两个值：true代表没有就添加，false代表没有不添加(默认值)。 六. update数组修改器 $push追加数组/内嵌文档值1db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$push:&#123;interest:&apos;draw&apos;&#125;&#125;) $push的功能是追加数组中的值1db.workmate.update(&#123;name:&apos;MinJie&apos;&#125;,&#123;$push:&#123;&quot;skill.skillFour&quot;:&apos;draw&apos;&#125;&#125;) $push修饰符内嵌文档增加值 $ne查找是否存在1db.workmate.update(&#123;name:&apos;xiaoWang&apos;,&quot;interest&quot;:&#123;$ne:&apos;playGame&apos;&#125;&#125;,&#123;$push:&#123;interest:&apos;Game&apos;&#125;&#125;) 如果xiaoWang的爱好（interest）里没有palyGame这个值，我们就加入Game这个爱好。总结：没有则修改，有则不修改。 \\$addToSet 升级版的\\$ne1db.workmate.update(&#123;name:&quot;xiaoWang&quot;&#125;,&#123;$addToSet:&#123;interest:&quot;readBook&quot;&#125;&#125;) 我们现在要查看小王(xiaoWang)兴趣(interest)中有没有阅读（readBook）这项，没有则加入读书(readBook)的兴趣. $each 批量追加123var newInterset=[&quot;Sing&quot;,&quot;Dance&quot;,&quot;Code&quot;];db.workmate.update(&#123;name:&quot;xiaoWang&quot;&#125;,&#123;$addToSet:&#123;interest:&#123;$each:newInterset&#125;&#125;&#125;)` 它可以传入一个数组，一次增加多个值进去，相当于批量操作，性能同样比循环操作要好很多，这个是需要我们注意的，工作中也要先组合成数组，然后用批量的形式进行操作. $pop 删除数组值1db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$pop:&#123;interest:1&#125;&#125;) $pop只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。 1：从数组末端进行删除,-1：从数组开端进行删除 数组定位修改1db.workmate.update(&#123;name:&apos;xiaoWang&apos;&#125;,&#123;$set:&#123;&quot;interest.2&quot;:&quot;Code&quot;&#125;&#125;) 七、修改：状态返回与安全","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Mongodb","slug":"Mongodb","permalink":"http://yoursite.com/tags/Mongodb/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}]},{"title":"TypeScript","slug":"TypeScript/TypeScript","date":"2019-04-29T07:22:37.000Z","updated":"2019-06-12T06:09:11.000Z","comments":true,"path":"2019/04/29/TypeScript/TypeScript/","link":"","permalink":"http://yoursite.com/2019/04/29/TypeScript/TypeScript/","excerpt":"","text":"一、准备 1. 安装npm install -g typescript 2. vscode自动编译 项目目录终端执行 tsc --init 更改tsconfig.json “outDir”: “./js” 二、基础语法 1.数据类型 布尔值 数字 字符串 数组 元组 Tuple 枚举 Any Void （函数没有返回值使用。） Null 和 Undefined （默认情况下null和undefined是所有类型的子类型。） Never （never类型是任何类型的子类型） Object 2.函数1234567891011121314151617181920212223242526272829303132333435363738394041424344声明函数function run():string &#123; return &apos;typescript&apos;;&#125;匿名函数var fun = function():string &#123; return &apos;typescript&apos;;&#125;定义方法传参function user(name:string,age:number):string &#123; return `$&#123;name&#125;----$&#123;age&#125;`;&#125;var user = function(name:string,age:number):string &#123; return `$&#123;name&#125;----$&#123;age&#125;`;&#125;没有返回值function run():void &#123; console.log(&apos;typescript&apos; );&#125;方法可选参数function user(name: string,age?:number):string &#123; return `$&#123;name&#125;----$&#123;age&#125;`;&#125;方法参数默认值function user(name: string,age:number=20):string &#123; return `$&#123;name&#125;----$&#123;age&#125;`;&#125;方法剩余参数function user(...result:number[]):string &#123; &#125;function user(name: string,...result:number[]):string &#123; &#125;重载function user(name: string):string;function user(age: number):number;function user(str:any):any &#123; if(typeof str===&apos;string) &#123; return str &#125; else &#123; return str &#125;&#125; 3.类123456789101112131415161718192021222324252627基本模型class Person &#123; name: string; //属性 省略publick 关键词 constructor(name:string) &#123; //构造函数 实例化的时候调用的方法(初始化对象) this.name = name; &#125; run():void &#123; alert(this.name); &#125;&#125;class Person &#123; name: string; //属性 省略publick 关键词 constructor(name:string) &#123; //构造函数 实例化的时候调用的方法(初始化对象) this.name = name; &#125; setName():void &#123; this.name = name; &#125; getName():string &#123; alert(this.name); &#125;&#125;var person1 = new Person(&apos;张三&apos;);alert(person1.getName());person1.setName(&apos;李四&apos;)；alert(person1.getName()); 4.继承123456789101112131415161718192021222324class Person &#123; name: string; //属性 省略publick 关键词 constructor(name:string) &#123; //构造函数 实例化的时候调用的方法(初始化对象) this.name = name; &#125; run():string &#123; return `$&#123;this.name&#125;` &#125;&#125;子类可以使用父类的属性和方法 如果子类的方法或者属性和父类相同 则以子类为主class Web extends Person &#123; constructor(name:string) &#123; super(name); //初始化父类的构造函数 &#125; work():string &#123; return `$&#123;this.name&#125;在运动` &#125; run():string &#123; return `$&#123;this.name&#125;` &#125;&#125;var w = new Web(&apos;李四&apos;);alert(w.run()); 5.类里面的修饰符 public 共有类型 在类里面、子类、类外面都可以访问(默认，不写默认就是)。 protected 保护类型 在类里面、子类可以访问，类外面都不可以访问。 private 私有类型 在类里面可以访问，子类和类外面都不可以访问。 6.类的静态属性和静态方法 static （静态方法里面不能直接调用类里面的属性，能调用静态属性） 12345678910111213class Person &#123; public name:string; static age:number=20; constructor(name) &#123; this.name = name; &#125; run() &#123; alert(`$&#123;this.name&#125;在运动`); &#125; static print() &#123; alert(`print`+Person.age); &#125;&#125; 7.多态 父类定义一个方法不去实现，让继承它的子类去实现，让每一个子类有不同的表现 12345678910111213141516171819202122232425class Animal &#123; name:string; constructor(name:string)&#123; this.name = name; &#125; eat() &#123; console.log(&apos;吃的方法&apos;); &#125;&#125;class Dog extends Animal &#123; constructor(name:string) &#123; super(name) &#125; eat() &#123; return this.name + &apos;骨头&apos; &#125;&#125;class Cat extends Animal &#123; constructor(name:string) &#123; super(name) &#125; eat() &#123; return this.name + &apos;鱼&apos; &#125;&#125; 8.抽象类 提供标准 abstract 抽象类不能实例化 为子类提供基类 子类必须实现父类的抽象方法 abstract必须放在抽象类里面 123456789101112131415abstract class Animal &#123; name:string; constructor(name:string)&#123; this.name = name; &#125; abstract eat():any;&#125;class Dog extends Animal &#123; constructor(name:any) &#123; super(name); &#125; eat() &#123; console.log(this.name); &#125;&#125; 8.接口 定义规范 定义行为和动作的规范 （接口不关心类内部的数据状态和方法实现的细节） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118interface FullName &#123; firstName: string; secondName: string;&#125;function printName(name: FullName) &#123; console.log(name.firstName+ &apos;--&apos; +name.secondName)&#125;var obj = &#123; firstName: &apos;sun&apos;, secondName: &apos;yu&apos;&#125;printName(obj) // ok接口的可选属性interface FullName &#123; firstName: string; secondName?: string;&#125;function printName(name: FullName) &#123; console.log(name.firstName+ &apos;--&apos; +name.secondName)&#125;var obj = &#123; firstName: &apos;sun&apos;, secondName: &apos;yu&apos;&#125;printName(obj) // okvar obj = &#123; firstName: &apos;sun&apos;&#125;printName(obj) // ok函数类型的接口interface encrypt &#123; (key:string,value:string):string;&#125;var md5:encrypt = function(key:string,value:string):string &#123; return key+value;&#125;md5(&apos;key&apos;,&apos;value&apos;);可索引接口 数组和对象的约束(不常用)interface userArr &#123; [index:number]:string&#125;var arr:userArr = [&apos;string&apos;,&apos;string&apos;]; //okinterface userObj &#123; [index:string]:string&#125;var arr:userObj = [&apos;string&apos;,&apos;string&apos;]; //ok类类型接口 对类的约束interface Animal &#123; name:string; eat(str:string):void;&#125;class Dog implements Animal &#123; name: string; constructor(name:string) &#123; this.name = name; &#125; eat() &#123; return `吃骨头`; &#125;&#125;var dog = new Dog(&apos;小黑&apos;);dog.eat();接口扩展 接口扩展接口interface Animal &#123; eat():void;&#125;interface Person extends Animal &#123; work():void;&#125;class Web implements Person &#123; public name:string; constructor(name:string)&#123; this.name= name; &#125; eat() &#123; console.log(this.name+&apos;喜欢吃馒头&apos;); &#125; work() &#123; console.log(this.name+&apos;爱工作&apos;); &#125;&#125;---------------------------interface Animal &#123; eat():void;&#125;interface Person extends Animal &#123; work():void;&#125;class programmer &#123; public: name:string; constructor(name:string) &#123; this.name = name; &#125; coding(code:string)&#123; console.log(this.name+code); &#125;&#125;class Web extends programmer implements Person &#123; constructor(name:string)&#123; super(name) &#125; eat() &#123; console.log(this.name+&apos;喜欢吃馒头&apos;); &#125; work() &#123; console.log(this.name+&apos;爱工作&apos;); &#125;&#125; 9.泛型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135function getData&lt;T&gt;(value:T):T &#123; return value;&#125;getData&lt;number&gt;(123);function getData&lt;T&gt;(value:T):any &#123; return value;&#125;getData&lt;number&gt;(123);getData&lt;string&gt;(&apos;123&apos;);泛型类class MinClass&lt;T&gt; &#123; public list:T[]=[]; add(value:T):void &#123; this.list.push(value); &#125; min():T&#123; var minNum = this.list[0]; for(var i=0;i&lt;this.list.length;i++) &#123; if(minNum&gt;this.list[i]) &#123; minNum = this.list[i]; &#125; &#125; return minNum; &#125;&#125;var m1 = new MinClass&lt;number&gt;(); // 实例化类 并且制定类的T代表类型是numberm1.add(123);var m2 = new MinClass&lt;string&gt;(); // 实例化类 并且制定类的T代表类型是stringm2.add(&apos;123&apos;);泛型接口interface ConfigFn &#123; &lt;T&gt;(value:T):T;&#125;var getData:ConfigFn = function&lt;T&gt;(value: T):T &#123; return value;&#125;getData&lt;string&gt;(&apos;张三&apos;);getData&lt;number&gt;(123);interface ConfigFn&lt;T&gt; &#123; &lt;T&gt;(value:T):T;&#125;function getData&lt;T&gt;(value: T):T &#123; return value;&#125;var myGetData:ConfigFn&lt;string&gt;=getData;myGetData(&apos;张三&apos;);var myGetDataw:ConfigFn&lt;number&gt;=getData;myGetData(123);把类作为参数来约束数据传入类型class User &#123; userName: string | undefined; password: string | undefined;&#125;class MysqlDb &#123; add(User:User):boolean &#123; console.log(User); return true; &#125;&#125;var user = new User();user.userName = &apos;张三&apos;;user.password = &apos;123456&apos;;var db = new MysqlDb();db.add(user); 泛型类class User &#123; userName: string | undefined; password: string | undefined;&#125;class MysqlDb &#123; add(User:T):boolean &#123; console.log(User); return true; &#125;&#125;var user = new User();user.userName = &apos;张三&apos;;user.password = &apos;123456&apos;;var db = new MysqlDb&lt;User&gt;();db.add(user);约束规范使用接口，代码重用使用泛型。interface DBI&lt;T&gt; &#123; add(info:T):boolean; update(info:T,id:number):boolean; delete(id:number):boolean; get(id:number):any[];&#125;class MysqlDb&lt;T&gt; implements DBI&lt;T&gt; &#123; add(info:T):boolean &#123; console.log(info); return true; &#125; update(info:T,id:number):boolean &#123; console.log(info,id); return true; &#125; delete(id:number):boolean &#123; console.log(id); return true; &#125; get(id:number):boolean &#123; console.log(id); return true; &#125;&#125;class Mongodb&lt;T&gt; implements DBI&lt;T&gt; &#123; add(info:T):boolean &#123; console.log(info); return true; &#125; update(info:T,id:number):boolean &#123; console.log(info,id); return true; &#125; delete(id:number):boolean &#123; console.log(id); return true; &#125; get(id:number):boolean &#123; console.log(id); return true; &#125;&#125; 10.模块 模块的概念(官方): ”内部模块“=》”命名空间“，”外部模块“=》”模块“ 模块在其自身的作用域里面执行，而不是在全局作用域执行。这就意味着定义一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确的使用export形式之一导出他们。相反，如果想使用其他模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用import形式之一。 模块的概念(自己理解): 我们可以把一些公共的功能单独抽离成一个文件作为一个模块。模块里面的变量，函数，类等都是私有的，如果我们要在外部访问模块里面的数据（变量，函数，类），我们需要通过export暴露模块里面的数据（变量、函数、类、、、）暴露后我们通过im\bport引用模块里面的数据（变量，函数，类）。 12345678910111213141516171819202122定义 db.tsvar a:string = &quot;string&quot;;function getData(value:string):string &#123; return value&#125;export &#123; a, getData&#125;使用import &#123; a,getDate &#125; form &apos;./db&apos;getData();import &#123; a,getData as get&#125; form &apos;./db&apos;get();定义 db.tsexprot default function getData(value:string):string &#123; return value&#125;使用import getData form &apos;./db&apos;getData(); 11.命名空间 命名空间和模块的区别： 命名空间，内部模块，主要用于组织代码，避免命名冲突。 模块，ts的外部模块的简称，侧重代码的复用，一个模块里可能会有多个命名空间。 12345678910111213141516171819202122232425262728293031323334353637383940namespace A &#123; interface Animal &#123; name:string; eat(str:string):void; &#125; export class Dog implements Animal &#123; name: string; constructor(name:string) &#123; this.name = name; &#125; eat() &#123; return `吃骨头`; &#125; &#125;&#125;var dog = A.Dog(&quot;小黑&quot;);dog.eat();命名空间封装成模块a.ts文件名定义export namespace A &#123; interface Animal &#123; name:string; eat(str:string):void; &#125; export class Dog implements Animal &#123; name: string; constructor(name:string) &#123; this.name = name; &#125; eat() &#123; return `吃骨头`; &#125; &#125;&#125;使用import &#123; a &#125; from &apos;./a&apos;var dog = new a.Dog();dog.eat(); 12.装饰器 装饰器： 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。 通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。 常见的装饰器有： 类装饰器、属性装饰器、方法装饰器、参数装饰器。 装饰器写法： 普通装饰器（无法传参）、装饰器工厂（可传参）。 装饰器是过去几年中js最大的成就之一，已经是Es7的标准特性之一。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621.类装饰器(普通装饰器，无法传参)function logClass(params:any)&#123; console.log(params); params.prototype.apiUrl=&quot;动态扩展的属性&quot;; params.prototype.run = function() &#123; console.log(&quot;我是run方法&quot;); &#125;&#125;@logClasshttpClient &#123; constructor() &#123; &#125; getData() &#123; &#125;&#125;var H = new httpClient();console.log(H.apiUrl);H.run();2.类装饰器(装饰器工厂，可传参)function logClass(params:string)&#123; return function(target:any) &#123; target.prototype.apiUrl=&quot;动态扩展的属性&quot;; target.prototype.run = function() &#123; console.log(&quot;我是run方法&quot;); &#125; &#125;&#125;@logClass(&apos;hello&apos;)httpClient &#123; constructor() &#123; &#125; getData() &#123; &#125;&#125;把类赋值给target把参数赋值给paramsvar H:any = new httpClient();console.log(H.apiUrl);H.run();类装饰器重载以前类的构造函数function logClass(target: any) &#123; console.log(target); return class extends target&#123; apiUrl:any = &quot;我是修改后的url&quot;; getData() &#123; console.log(this.apiUrl); &#125; &#125;&#125;@logClasshttpClient &#123; public apiUrl: string | undefined; constructor() &#123; this.apiUrl = &apos;url&apos;; &#125; getData() &#123; console.log(this.apiUrl); &#125;&#125;var http = new httpClient();------------------------------3.属性装饰器(属性装饰器表达式会在运行时当作函数调用，传入下列两个参数，对于静态成员来说是类的构造函数，对于实例成员是类的原型对象)function logClass(params:any)&#123; console.log(params); params.prototype.apiUrl=&quot;动态扩展的属性&quot;; params.prototype.run = function() &#123; console.log(&quot;我是run方法&quot;); &#125;&#125;function logProperty(params:string)&#123; return function(target: any,attr:any) &#123; console.log(target); console.log(target[attr]); target[attr] = params; &#125;&#125;@logClass(&apos;xxx&apos;)httpClient &#123; @logProperty(&quot;http://baidu.com&quot;); public url: string | undefined; constructor() &#123; &#125; getData() &#123; console.log(this.url); &#125;&#125;var http = new httpClient();http.getData();4.方法装饰器它会被应用到的方法的属性描述符上，可以用来监视，修改或者替换方法定义方法装饰器会在运行是传入下列3个参数（1）对于静态成员来说类的构造函数，对于实例成员来说是类的原型对象。（2）成员的名字。（3）成员的属性描述符。function logMethod(params: any) &#123; return function(target:any,methodName:any,desc:any) &#123; console.log(target); console.log(methodName); console.log(desc); target.apiUrl=&quot;动态扩展的属性&quot;; target.run = function() &#123; console.log(&quot;我是run方法&quot;); &#125; &#125;&#125;httpClient &#123; constructor() &#123; &#125; @logMethod(&quot;http://baidu.com&quot;) getData() &#123; console.log(this.url); &#125;&#125;var http:any = new httpClient();http.run();------------------------------------------function logMethod(params: any) &#123; return function(target:any,methodName:any,desc:any) &#123; console.log(target); console.log(methodName); console.log(desc); //修改装饰器的方法 把装饰器方法传入所以参数改为string类型 //保存当前的方法 var oMethod = desc.value; desc.value = function(...args:any[]) &#123; args = args.map((value)=&gt;&#123; return String(value) &#125;); console.log(args); &#125; &#125;&#125;httpClient &#123; public url:any | undefined; constructor() &#123; &#125; @logMethod(&quot;http://baidu.com&quot;) getData() &#123; console.log(this.url); &#125;&#125;var http:any = new httpClient();http.getData(123,&apos;xxx&apos;);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javascript 面向对象：1","slug":"面向对象/面向对象第一天","date":"2019-04-25T14:58:51.000Z","updated":"2019-04-26T06:38:35.000Z","comments":true,"path":"2019/04/25/面向对象/面向对象第一天/","link":"","permalink":"http://yoursite.com/2019/04/25/面向对象/面向对象第一天/","excerpt":"","text":"一、 面向对象：是一个基于对象的多范式的编程语言多范式：编程风格 面向过程的方法编程 面向对象的方式编程 函数式 二、 面向对象的基本概念 JS 是不是一个面向对象的语言? 不是: 与传统面向对象的理论有矛盾. C#, JAVA 是: JS 里面到处都是对象. 数组, 时间, 正则 … 和 DOM 也可以像传统面向对象的语言那样用 NEW 的方式创建对象 JS 是一个基于对象的多范式的编程语言 多范式: 编程风格 面向过程的方式编程 面向对象的方式编程 函数式 ... 函数式的一个特点: 递归与链式 JQUERY 就是典型的链式编程风格 比如: 给 DIV 标签添加样式$( &apos;DIV&apos; ).CSS( &apos;BORDER&apos;, &apos;1PX SOLID RED&apos; ) .CSS( &apos;WIDTH&apos;, &apos;400PX&apos; ) .CSS( &apos;HEIGHT&apos;, &apos;200PX&apos; ); 面向对象的概念 -&gt; 面向: 将脸朝向 ... -&gt; 关注, 用 面向过程开发 -&gt; 使用过程的方式开发 面向对象开发 -&gt; 使用对象开发 -&gt; 面向过程 早上吃早饭: 吃面 自己做: 和面 -&gt; 压成细面 -&gt; 烧水 -&gt; 煮面 -&gt; 盛面 -&gt; 吃 过程: 步骤, 细节, 顺序等 -&gt; 今天早上 找到对象: 找到面馆 -&gt; 要 -&gt; 吃 -&gt; 面向对象: 要做什么, 就找到对应的对象, 告诉它做, 等结果 -&gt; 生活 买菜: 菜场 公交 电话 ... -&gt; 是否说面向对象可以取代面向过程 面向对象是面向过程的封装 -&gt; 万物皆对象 在实际开发中, 对象是一个抽象的概念, 可以将其简单的理解为: 数据集或功能集. -&gt; 数据集: 很多数据打包到一起. { NAME: &apos;张三&apos;, AGE: 19, GENDER: &apos;男&apos; } 假设展示 10 条商品数据. 每一个商品: 名字, 描述, 价格, 图片 -&gt; 每一条数据可以变成对象: { NAME:&apos;&apos;, DESC: &apos;&apos;, PRICE: 0, IMG: &apos;&apos; } -&gt; 引入数组, 将数据存储到数组中 -&gt; 功能集(函数集, 方法集) -&gt; 在 JS 中, 所谓的对象就是 键值对的 集合 -&gt; 也可以混合使用 例如 JQUERY: $( &apos;DIV&apos; ) 这个是一个 JQ 对象, 但是实际上里面包含 DOM 对象 $( &apos;DIV&apos; ).CSS( ... ) $( &apos;DIV&apos; ).HTML( ... ) 是不是就说明 JQ 对象中包含方法 -&gt; 抽象性 商品列表: 书店, 书的列表 书名, 页数, 简介, 编号, 作者 对象只包含最核心的主要信息 游戏人物: 英雄 名字, 血量, 防御, 攻击, 护甲, 武器 只需要描述出需要的数据即可 -&gt; 名词提炼法找对象 做一个表格排序 -&gt; 过程 1) 创建表格 2) 添加点击事件 3) 排序, 更新数据 -&gt; 对象 1) 创建表格对象 2) 添加数据 -&gt; 实际开发的时候如果需要完成一个功能 -&gt; 首先考虑系统是否提供了对象 例如创建图片: VAR IMG = NEW IMAGE(); IMG.SRC = &apos;...JPG&apos;; 例如获取页面元素: DOCUMENT, 标签对象 例如获得导航栏里面的所有的 LI 标签 VAR NAV = DOCUMENT.GETELEMENTSBYID( &apos;NAV&apos; ); // NAVIGATION VAR LIS = NAV.GETELEMENTSBYTAGNAME( &apos;LI&apos; ); -&gt; 如果系统没有可以考虑自定义, 或第三方 VAR ITCAST = { TAG: FUNCTION ( TAGNAME ) { RETURN DOCUMENT.GETELEMENTSBYTAGNAME( TAGNAME ); }, ADDCSS: FUNCTION ( ARRAY, STYLES ) { FOR ( VAR I = 0; I &lt; ARRAY.LENGTH; I++ ) { FOR ( VAR K IN STYLES ) { ARRAY[ I ].STYLE[ K ] = STYLES[ K ]; } } }, ID: FUNCTION () {}, CNAME: FUNCTION () {}, NAME: ... ATTR: ... CLASS: ... ... }; 开发者工具的打开: F12 火狐的 FIREBUG 调试按钮 -&gt; 逐语句: 单步运行. 就是一次只执行一句话. 如果遇到函数, 进入函数体内一步一步执行 -&gt; 逐过程: 一次执行一个过程. 如果是一条语句那么与逐语句是一样的. 但是如果是一个函 数, 那么他就会将函数执行完, 然后在往下走, 停下来. -&gt; 继续运行 条件断点 就是只有在 条件满足的时候(表达式为真的时候) 才会停下来的断点 利用调试工具实现列表播放 H5 提供了 两个标签, 一个是 AUDIO, 一个是 VIDEO AUDIO 主要是用来播放音乐的 VIDEO 用来播放视频 如果标签设置了属性 AUTOPLAY SRC 我希望当一个音乐播放完成后, 自动播放下一首 数据在内存中的存储形式(识记) 计算机只认识数字 计算机根据是否有电信号表示1或0: 准确的说是高低电平 有了二进制数据( 有兴趣的同学可以学习如何转换 ) 计算机只认识数组, 那么如何表示语言 ASCII 码 0 ~ 127 数字 对应的 表示成 字母 前 32 个 是控制字符 从 32 开始 到 127 是可视化字符 &apos;0&apos; 48 &apos;A&apos; 97 &apos;A&apos; 65 有了这样一个对应关系(映射 MAP), 那么一段文字就可以使用一串数字表示了 表示中文的 GB2312 编码, 简体中文编码. 英文标点和数字等使用一个字节 中文使用两个字节. UNICODE 编码( 万国码 ). 所有的字符才偶用两个字节表示. 例如表示字符 &apos;A&apos; 2 个字节 在页面中使用最多的是: 数字, 字母, 标点符号 UTF-8 编码( 通用转换格式 ). 所有与 ASCII 编码相符的字符采用一个字节. 而汉字采用 3 个字节. 在 JS 中允许使用 UNICODE 编码表示字符串 语法: \\U + 4 位 16 进制数 使用这种方式表示数据, 在表示 与 ASCII 码重合字符是没有意义的. 但是对于中文 由于存在不同的编码, 而不同编码在不同平台上可以正常显示, 但是随着网络传播, 不是在所有平台上可以通用. 因此数据传送中文一般采用 UNICODE 编码形式. 数字 + 上下文 = 信息 97 ‘A’ 数字 97 在此处不要深究, 只需要了解内存模型即可. 内存就是一个可以存储数字( 数据 )的盒子. JS 的数据类型-&gt; 基本类型( 值类型 ): 数字 NUMBER, 字符串 STRING, 布尔 BOOLEAN-&gt; 复合类型( 引用类型 ): 对象( 数组, 时间类型, 函数类型, 正则表达式, … )-&gt; 空类型: NULL, UNDEFINED 基本数据类型和空类型的存储模型就是一个方格里面放一个数据 复合类型, 除了函数, 其他的数据类型无法使用 TYPEOF 获得数据类型名 注意: 如果需要获得对象的数据类型, 需要使用 OBJECT.PROTOTYPE.TOSTRING.APPLY( 数据 ) 复合类型的存储方式VAR P = { NAME: ‘ITCAST’ } 复合类型的对象是一个单独的内存区域, 对象有什么属性, 那么内存区域中就有什么数据.变量 P 只存储该对象的 ‘地址’. 所以 P 不是真正存储数据的区域. 绘制数据的内存逻辑图 VAR ARR1 = [ 1, 2, 3, 4 ];VAR ARR2 = [ { NAME: &apos;张三&apos;, AGE: 19, GENDER: &apos;男&apos; }, { NAME: &apos;李四&apos;, AGE: 18, GENDER: &apos;男&apos; }, { NAME: &apos;小李&apos;, AGE: 17, GENDER: &apos;女&apos; } ]; 值类型与引用类型的存储特征-&gt; 值类型的数据, 只需要开辟一段内存存储数据即可 VAR A = 123; VAR B = &apos;ABC&apos;; VAR C = TRUE; -&gt; 对象类型( 引用类型 ). 对象才是真正的数据, 需要占据单独的内存. 而变量名只是存储着对象的内存地址( 引用 ). 即创建一个对象并赋值, 实际上需要两块内存空间. 一个存储数据( 对象 ), 另一个存储变量以引用对象. VAR O = { NAME: &apos;张三&apos;, AGE: 19, GENDER: &apos;男&apos; }; 值类型与引用类型的赋值与传参的特性-&gt; 赋值: 将原变量中的数据拷贝一份, 然后存储到给定变量中 -&gt; 值类型 VAR A = 123; // 有一个盒子, 叫 A, 里面存储着数字 123 VAR B; // 又有一个盒子, 叫 B, 里面什么都没存( UNDEFINED ) B = A; // 将 A 中存储的东西复制一份, 然后赋值给 B. 即存储在 B 中 B 和 A 是两个独立的变量, 两者之间不再有关系. 改变其中一个数据, 另一个不变 -&gt; 引用类型 VAR O1 = { NUM: 123 }; VAR O2; // 赋值 O2 = O1; // 将 O1 中存储的内容 拷贝一份 存储到 O2 中 // O1 中存储的是引用, 或 &apos;地址&apos; O1 和 O2 虽然是不相同的两个变量, 即两个独立的盒子. 但是由于存储的地址相同. 在访问数据的时候, O1 与 O2 也是访问同一个数据, O1 将数据修改了, O2 再读取, 读取的就是修改后的数据. -&gt; 函数参数传递 -&gt; 什么是函数参数传递 函数要调用, 一般会给函数传递参数 在调用函数的时候, 回将参数中表示的数据拷贝一份, 然后给参数赋值 FUNCTION FOO( NUM ) {} // 调用 VAR A = 123; FOO( A ); // 调用函数就是要执行函数 // 将 A 中存储的数据 拷贝一份 // 进入 函数 FOO // 给参数赋值, 相当于 NUM = A // 进入函数体, 开始执行函数 此时的赋值特性与前面介绍的值类型引用类型的赋值是一个特点 深拷贝与浅拷贝-&gt; 什么是拷贝: 就是创建一个与目标数据一模一样的数据-&gt; 案例: VAR P = { NAME: &apos;张三&apos; }; VAR P1 = P; // 是否存在拷贝 // 一般描述拷贝是指拷贝对象 P1 = {}; P1.NAME = P.NAME; // 才是拷贝 -&gt; 案例, 给 对象 P 提供一个 CLONE 方法, 完成拷贝 -&gt; 案例: 有一辆汽车 CAR: NAME=保时捷 有一个人 PERSON : NAME=张三 -&gt; 如果对象的属性也是一个引用类型, 拷贝的时候不重新创建一个新的对象来实现该属性的拷贝, 那么就是浅拷贝. 即任何不完全的拷贝都是浅拷贝 -&gt; 将两个对象完全从内存中隔离开, 就是深拷贝. 即每一个引用属性, 以及引用属性的引用属性, … 全部拷贝出来. 构造函数( 构造器 CONTROCTOR )的作用-&gt; JS 中对象的动态特性 即 想要什么属性就可以提供什么属性 在 JS 中 对象如果没有指定的属性, 只需要利用赋值就可以给对象提供该属性. -&gt; 点语法与关联数组语法 O.NAME = &apos;JIM&apos;; // 点语法赋值（NAME是一个名字） CONSOLE.LOG( O.NAME ); // 点语法取值 O[ &apos;NAME&apos; ] = &apos;TOM&apos;; // +关联数组语法赋值（NAME一定要是字符串） O[AGE]; //会出错 AGE不存在 O[ &apos;NAME&apos; ] = &apos;TOM&apos;; //这里的NAME不能为对象 CONSOLE.LOG( O[ &apos;NAME&apos; ] ); // 关联数组语法取值 问题: // 如果 NAME 是一个变量, 里面存储的是 字符串, 也是可以的 O[ NAME ] = &apos;JACK&apos;; // 对或不对? WINDOW.NAME 为空 &quot;&quot; WINDOW里面有NAME -&gt; 例创建一个 PERSON 对象 VAR P = {}; // 什么都没有的对象 // 根据需要添加成员 P.NAME = &apos;张三&apos;; P.AGE = 30; P.GENDER = &apos;男&apos;; -&gt; 简化: 提供一个创建 PERSON 对象的函数 FUNCTION CREATEPERSON( NAME, AGE, GENDER ) { VAR P = {}; P.NAME = NAME; P.AGE = AGE; P.GENDER = GENDER; RETURN P; } VAR P1 = CREATEPERSON( &apos;JIM&apos;, 19, &apos;男&apos; ); VAR P2 = CREATEPERSON( &apos;LILY&apos;, 18, &apos;女&apos; ); 这个( 这种类型 )的函数就是用来创建对象的, 即生产对象. 常常将这类函数 称为 &apos;工厂函数&apos; 构造方法创建对象-&gt; 构造器中不需要 RETURN 语句. 一般也可以不写-&gt; 调用构造器的时候, 使用 NEW 运算符引导-&gt; 在构造器中 THIS 表示当前对象. 给对象提供成员使用 THIS.XXX 的 方式 -&gt; 将 CREATEPERSON 改造成构造器 // 构造器的定义 FUNCTION CREATEPERSON( NAME, AGE, GENDER ) { THIS.NAME = NAME; THIS.AGE = AGE; THIS.GENDER = GENDER; } // 调用构造器创建对象 VAR P = NEW CREATEPERSON( &apos;李磊&apos;, 19, &apos;男&apos; ); 当构造函数，同时出现RETUR和NEW的时候，看RETURN后面的值， 如果为数值则返回THIS ，如果是引用类型，就返回引用类型。 -&gt; 构造器创建对象的本质: 还是使用对象的动态特性 -&gt; 首先执行 NEW 运算符. 即创建对象. 可以简单看做为 {} 的简写 VAR P = NEW ... &apos;相当于&apos; VAR P = {} -&gt; 调用构造器. 并隐含一个参数, 即刚刚创建的对象. -&gt; 在构造器中使用 THIS 引用刚刚创建出来的对象. -&gt; 构造器结束是 默认返回 THIS 本质还是利用对象的动态特性 -&gt; 补充说明 -&gt; 构造器的名字, 一般使用 PASCAL 命名规则( 首字母大写的 ) -&gt; 一般为了与其他面向对象的编程语言( C++, C#, JAVA )保持一致. 称构造函数名为类名 FUNCTION PERSON( NAME, AGE, GENDER ) { THIS.NAME = NAME; THIS.AGE = AGE; THIS.GENDER = GENDER; } // 调用构造器创建对象 VAR P = NEW PERSON( &apos;李磊&apos;, 19, &apos;男&apos; ); 异常与捕获-&gt; 异常 简单的说, 就是代码在执行过程中出现的错误. 并不是代码的语法错误. -&gt; 一旦出现异常, 其后的代码, 不再执行 -&gt; TRY-CATCH 语法 1) TRY-CATCH 形态 TRY { 代码 } CATCH ( E ) { 代码 } 2) TRY-CATCH-FINALLY 形态 TRY { 代码 } CATCH ( E ) { 代码 } FINALLY { 代码 } （无论代码出错还是没有出错都要执行） -&gt; 自定义抛出异常 一般可以封装函数完成特定的功能. 例如 TAG 函数 FUNCTION TAG ( TAGNAME ) { IF ( TAGNAME 不是字符串 ) 抛出异常. RETURN DOCUMENT.GETELEMENTSBYTAGNAME ( TAGNAME ); } -&gt; 抛出异常的语法 THROW 对象 DOM 的核心内容-&gt; 什么是 DOM, 为什么需要 DOM &lt;DIV&gt;&lt;DIV&gt;&lt;/DIV&gt;&lt;DIV&gt;&lt;/DIV&gt;&lt;/DIV&gt; -&gt; DOM 操作操作的是什么? -&gt; 访问各亲属节点 -&gt; 增删改查 -&gt; 学会分析 DOM 树 &lt;DIV&gt; &lt;P&gt;你好, 我是一个 &lt;SPAN STYLE=&quot;COLOR: RED&quot;&gt;DOM&lt;/SPAN&gt; 树的练习&lt;/P&gt; &lt;/DIV&gt; 在 HTML 文件结构中吗所有的内容都是节点(NODE)对象. 有的是文本节点. 有的是标签( 元素 ELEMENT )对象. 还有的是属性节点( ATTRIBUTE NODE )对象. 访问各个亲属节点-&gt; 节点对象的常用属性 &lt;NODE&gt;.NODETYPE 元素(标签): 1, 属性: 2, 文本: 3 &lt;NODE&gt;.NODENAME 元素(标签): 大写的标签名, 属性: 属性名 文本: #TEXT &lt;NODE&gt;.NODEVALUE 元素(标签): NULL 属性: 属性赋值等号后面的值 文本: 文本字符串 操作 DOM 就是创建元素, 插入元素, 修改元素, 查询元素, 删除元素-&gt; 增加 // 创建 DOCUMENT.CREATEELEMENT( &apos;元素名&apos; ) 创建元素标签 DOCUMENT.CREATETEXTNODE( &apos;文本内容&apos; ) 创建文本节点 // 插入 &lt;PARENT&gt;.APPENDCHILD( 子元素 ) 追加到子元素的结尾 &lt;PARENT&gt;.INSERTBEFORE( 新元素, 旧元素 ) 将新元素插入到旧元素的前面 // 简单的办法 &lt;ELEMENT&gt;.INNERHTML = ... &lt;ELEMENT&gt;.INNERTEXT = ... // 增加属性 &lt;ELEMENT&gt;.属性名 = ... &lt;ELEMENT&gt;.SETATTRIBUTE( 属性名, 值 ); &lt;ELEMENT&gt;.STYLE.XXXX = ... -&gt; 删除 &lt;PARENT&gt;.REMOVECHILD( 子元素 ); &lt;ELEMENT&gt;.SETATTRIBUTE( 属性, &apos;&apos; ) &lt;ELEMENT&gt;.XXXX = NULL -&gt; 修改 -&gt; 修改属性 &lt;ELEMENT&gt;.XXX = ... &lt;ELEMENT&gt;.SETATTRIBUTE( 属性名, ... ) -&gt; 修改节点 -&gt; 查询 手动创建一个 TABLE 表格, 并且在里面显示数据VAR ARR = [ { NAME: &apos;JIM1&apos;, AGE: 19, GENDER: &apos;男&apos; }, { NAME: &apos;JIM2&apos;, AGE: 18, GENDER: &apos;男&apos; }, { NAME: &apos;JIM3&apos;, AGE: 20, GENDER: &apos;男&apos; }, { NAME: &apos;JIM4&apos;, AGE: 18, GENDER: &apos;男&apos; } ]; # ##","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"seajs和requirejs","slug":"seajs  and requirejs","date":"2017-03-04T04:50:07.000Z","updated":"2019-04-26T06:09:07.000Z","comments":true,"path":"2017/03/04/seajs  and requirejs/","link":"","permalink":"http://yoursite.com/2017/03/04/seajs  and requirejs/","excerpt":"","text":"为什么要使用模块化 全局变量、全局函数，容易造成变量名冲突 页面引入了一堆的js文件，存在先后顺序的问题 代码由于组织混乱很容易出错 出错了很难调试 后期难以维护 模块化的好处 提升开发效率 便于后期维护 模块化理解模块化是一种组织代码的方式，当我们的项目越来越复杂的时候，如果把很多功能业务逻辑写在一起，就会造成开发起来十分的繁琐(因为经常会遇到变量命名冲突、文件依赖过于混乱的问题)，同时维护起来也十分的麻烦，这时候，我们可以考虑把代码按照功能等方面把整个项目划分成一个一个的模块，这样，当我们开发的时候，我们每次只需要关注这一小功能点是如何实现的，从而简化了开发的难度，这样可以提高我们开发的效率，同时，后期维护起来也会变得更加的简单。 cmd规范特性 一个模块就是一个单独的文件 由于每个模块都是属于define关键字函数的回调函数被调用，每个模块都是一个单独的作用域 预加载、懒执行（预加载就是预先把所有的模块全部加载完，懒执行就是需要执行哪块才执行哪块） 关键字 define 定义一个模块 require 加载一个模块 exports 暴露一个模块 module 模块 注意点 define(function(require,exports,module){});这里面的require,exports,module三个参数的名字是固定写法，不能简写，顺序不能错了 记忆方法：rem 如果define里的参数想省略，只能从后面开始省略，只要写了后面的，前面的必须要写上 –&gt; 推荐写全，不要省 如果一个模块既不需要公开成员变量，也不需要依赖第三方模块，那么可以全部省略 seajs.use(“入口模块”)可以加回调函数，形式如：seajs.use(“入口模块”,callback); 路径问题 在sea.js当中，js/main和./js/main的含义不是一样的 js/main代表的是在sea.js所在的文件为基准去找，所以找到的是 –&gt; SEAJS所在的父级文件夹/js/main.js 这样的话会找不到的(相对seajs包的路径) ./js/main代表的是以当前html文件去找js文件夹下面的main.js require(“xxx”) –&gt; 其实这里的xxx叫模块标识，不是路径 config的作用就是为了简化调用模块 base 设置路径 alias 设置模块的别名，简化调用 seajs使用1. 引包&lt;script src=&quot;js/sea.js&quot;&gt;&lt;/script&gt; 2. 入口模块//为了简洁，路径最好不加.js //加载完成后触发回调函数 //简化调用模块 seajs.config({ //base 设置路径 //alias 设置模块的别名，简化调用 base:&quot;./js&quot; alias:{ m:&quot;main&quot; } }) seajs.use(&quot;./js/main&quot;,function(){ console.log(&apos;代码执行成功&apos;); }); 3. 主模块// 名字写全 并且顺序和单词都要写对（便于记住rem） define(function (require, exports, module) { // require 方法得到的就是指定的模块中向外暴露的接口对象 module.exports // var fooModule = require(&apos;./foo&apos;) // console.log(fooModule.foo) var foo = require(&apos;./foo&apos;) console.log(foo) }); 4. 第三方模块define(function (require, exports, module) { // 每个文件模块都是一个模块作用域，外部是无法直接拿到的里面的东西的 var foo = &apos;bar&apos;; // 默认情况下 module.exports 就是一个空对象 // module.exports.foo = foo module.exports = &apos;bar&apos;; }); sea.js把非cmd模块转换成cmd模块// 判断的左右就是防止jquery不作为cmd模块使用的时候也可以用 if (typeof define === &apos;function&apos; &amp;&amp; define.cmd) { define(function(require,exports,module){ module.exports = jQuery; }); } require.js引包//data-main引入主模块包 &lt;script src=&quot;js/lib/require.js&quot; data-main=&quot;js/app/main&quot;&gt;&lt;/script&gt; //如果想用jQuery,则必须配置如下： require.config({ baseUrl:&apos;./js/app/&apos;,//这里设置的是main的路径 paths:{ &quot;jquery&quot;:&quot;../lib/jquery&quot; } }); main//类似angular //[&apos;./cal&apos;]映入第三方模块 requirejs([&apos;./cal&apos;],function(calculator){ }); 第三方模块define(function(){ //用return 提供接口暴露数据 return });","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"模块化开发","slug":"模块化开发","permalink":"http://yoursite.com/tags/模块化开发/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"css3 知识汇总","slug":"css3","date":"2017-02-27T14:18:38.000Z","updated":"2019-04-26T06:18:18.000Z","comments":true,"path":"2017/02/27/css3/","link":"","permalink":"http://yoursite.com/2017/02/27/css3/","excerpt":"","text":"如何使用手册学会使用工具，可以让我们事半功倍。 []表示全部可选项 ||表示或者 |表示多选一 ？表示0个或者1个 *表示0个或者多个 {}表示范围一、选择器 属性选择器：–ele[attr] 选取包含这个属性的元素–ele[attr=value] 选取这个attr属性有且只有value这一个值的元素–ele[attr^=value] 选取这个attr属性中以value字符开头的元素–ele[attr$=value] 选取这个attr属性中以value字符结尾的元素–ele[attr*=value] 选取这个attr属性中以包含value字符的元素–ele[attr~=value] 选取这个attr属性中有value这个属性值的元素 伪类选择器：–ele:first-child 选取当前元素的父级下的第一个子元素–ele:last-child 选取当前元素的父级下的最后一个子元素–ele:nth-child(xn+y) 选取当前元素的父级下的第xn+y个子元素–ele:nth-last-child(xn+y) 选取当前元素的父级下的倒数第xn+y个子元素–ele:empty 选取当前元素下没有任何子元素或文本的元素（注释不算，但是空格算 通常用在购物车计数）–ele:not(.class) 选取的是除了这个元素之外的元素–ele:target 处在锚点状态下的元素（也就是当前元素被锚点状态）–ele:checked 选取的是当前处在checked状态下的元素（用于input标签中的单选和复选框）–ele:enabled 选取的是当前处在enabled状态下的元素（用于按钮）–ele:disabled 选取的是当前处在disabled状态下的元素（用于按钮） 伪元素选择器：–ele:before/ele::before 在当前元素下添加一个before伪元素处在当前元素下最开始的位置–ele:after/ele::after 在当前元素下添加一个after伪元素处在当前元素下最末尾的位置 element::before/element::after {content:&apos;&apos;; 这里可以填内容 通常为空(如果设置文本内容,则会在该伪元素上显示文本内容) display:block; 新建的伪元素是一个行内元素,在使用的时候通常转换为块级元素,但是不一定要转换(也可以通过定位或者浮动来改变成块级元素) width:; height:; ... } --ele::first-letter 当前文本的首字母（也可以是第一个字） --ele::first-line 当前文本的第一行（是相对的） --ele::selection 设置选中区域的样式(可以设置字体颜色和背景颜色等,但是不可以改变字体大小) --input::-webkit-input-placeholder{}选中input里的placeholder并设置样式 注意:伪元素选择器前面的两个点最好写成一个,以为现在的浏览器默认会添加成两个. 4. 小技巧 -webkit-user-select:none;当前元素下的文字不可选中 二、颜色 color属性可以赋什么值– red 直接写代表颜色的英文单词– #CCCCCC 16进制表示方法– rgb(0,0,0) 三个参数值分别是0-255，0-255，0-255– rgba(0,0,0,0) 四个参数值分别是0-255，0-255，0-255,0-1最后一个参数表示透明度，不会被其子盒子继承– hsl(0,0%,0%) 三个参数值分别是0-360，0%-100%，0%-100%– hsla(0,0%,0%,0) 四个参数值分别是 色调0-360,饱和度0%-100%(但这个参数为0的时候,必须为0%才不会出错)，亮度0%-100%,0-1最后一个参数表示透明度，不会被其子盒 子继承 -- transparent 完全透明的意思，不可以调节透明度 opacity 表示透明度的意思，取值为0-1之间的数字，会被子盒子继承 三、文字阴影 text-shadow: 0px 0px 0px red 文字阴影– 第一个参数表示阴影左右移动的距离（正值向右，负值向左）– 第二个参数表示阴影上下移动的距离（正值向下，负值向上）– 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊– 第四个参数表示阴影颜色(后面可以在用逗号,在添加一个文字阴影.)四、边框 border-radius: 0px 0px 0px 0px / 0px 0px 0px 0px 边框圆角（可以是正圆角也可以是椭圆角，当X/Y轴半径不一样的时候即为椭圆角，如果X/Y轴半径一样，那么“/”后 面的值可以省略不写） – 0 0 0 0 / 0 0 0 0; 标准写法 分别表示1、2、3、4 位置的X/Y轴半径 – 0 0 0 / 0 0 0; 简写 分别表示 1、2/4、3 位置的X/Y轴半径 – 0 0 / 0 0; 简写 分别表示 1/3、2/4 位置的X/Y轴半径 – 0 / 0; 简写 表示四个位置的X/Y轴半径 box-shadow: 0px 0px 0px red 盒子阴影– 第一个参数表示阴影左右移动的距离（正值向右，负值向左）– 第二个参数表示阴影上下移动的距离（正值向下，负值向上）– 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊– 第四个参数表示阴影颜色 border-image: url(“”) 27 stretch repeat 边框背景图片（复合属性，也可以拆开写）– 第一个参数表示边框背景图片的引入地址– 第二个参数表示引入的图片中以什么样的尺寸来分割成九份– 第三个参数表示X轴方向的填充方式（round，repeat，stretch）– 第四个参数表示Y轴方向的填充方式（round，repeat，stretch）– border-image-source: url(“”);– border-image-slice: 27 27 27 27 fill;（背景图片裁切尺寸，最后的fill是表示中间内容区域也显示为图片的中间区域，如果不写默认为中间内容区域留白）– border-image-repeat: stretch repeat round;– border-image-width: 20px;– border-image-outside:1/0px;虚拟变大,只是占以前的大小,不会影响旁边的元素 .设置的值有两种, 数字代表扩大自己的倍数 ,具体的像素.说明: stretch拉伸 repeat平铺(两边会被裁剪) round显示全部浏览器自动调整 五、盒模型 box-sizing:border-box （以边框方式计算盒子的大小）– border-box 设置为border-box以后，我们设置的盒子（width/height）即为content+padding+border– content-box 设置为border-box以后，我们设置的盒子（width/height）即为content（默认）说明: 默认的box-sizing:content-box;优先保证内容的大小 对盒子进行缩放. box-sizing:border-box;让盒子优先保证自己所占域的大小,对内容进行压缩.六、背景 background-size: 10px 10px 背景图片的尺寸大小（也可以设置为contain、cover）–contain 图片两边等比例拉伸，直到某一边顶格停止拉伸（长边位置顶格后，短边位置不再拉伸，其余位置留白）–cover 图片等比例拉伸，保证两边都顶格，可能会出去（短边位置顶格，长边位置溢出盒子） background-position: 10px 10px/top left 背景图片定位 background-origin: 背景图片的开始位置–border-box 让图片背景在border开始的位置开始显示–padding-box 让图片背景在padding开始的位置开始显示（默认）–content-box 让图片背景在content开始的位置开始显示 background-clip:–content-box 内容区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切）–padding-box padding区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切） background-image–background-image:url(“”),url(“”),…,…; 多张背景图片以逗号分隔可以引入多张背景图片–background-position:top left,top left;当设置了多重背景时要设置背景位置时也用逗号隔开设置,其位置时一一对性的. 七、渐变 linear-gradient() 线性渐变–第一个参数表示线性渐变的方向（to top/right/bottom/left，也可以是具体的角度360deg）–第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%）–第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少,为什么颜色）–第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写）–…… radial-gradient() 径向渐变–第一个参数表示径向渐变的范围（为半径值）–第二个参数表示径向渐变的开始位置（at 渐变开始的位置，也可以是具体的值）–第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%）–第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少为什么颜色）–第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写）–…… http://www.colorzilla.com/gradient-editor/ 自动生成全兼容渐变代码具体说明: 渐变 线性渐变background-image:linear-gradient(to right,yellow,green);黄色从左到右渐变为绿色方向还可以用度数但是要带单位deg 0deg向上 90deg向右background:linear-gradient(90deg,yellow 25%,green);开始%25是黄色不开始渐变,过了%25之后才开始渐变(这个百分比相当于 整个盒子)background:linear- gradient(90deg,yellow 25%,green 50%); 还可以个多个值:例如 background:linear-gradient(90deg,yellow 25%,green 25%m,pink 50%); 方向 颜色 范围 径向渐变 有原点(圆心) 两种颜色 background-image:radial=gradient(120px at center center,yellow,green); 第一个参数是半径 后面两个是坐标 左后是颜色 background-image:radial=gradient(120px 80px at center center,yellow,green); 写了两个半径就是椭圆 后面坐标可以用单词 给百分比 和具体的数值 background-image:radial=gradient(120px 80px at center center,yellow,green 25%,blue);和线性渐变基本一样总结注意:要想不要渐变的效果就这样设置background:linear-gradient(90deg,yellow 25%,green %25,green 50%) ;八、过渡动画 transition: all 1s 1s ease 过渡动画（从其实状态到结束状态的改变，只能是两个这状态的改变）–后面参数的书写顺序没有具体规定，不过出现的第一个时间一定是过渡需要的时间，第二个才是延迟时间–一般大家默认写成（属性、过渡时间、延迟时间、线性）–第一个参数为transition-property 是我们需要的过渡的属性（可以是单一的某一个，如果全部都过渡就写all）–第二个参数为transition-duration 是完成本次过渡动画的总时间–第三个参数为transition-delay 是本次动画开始是的延迟时间–第四个参数为transition-timing-function 是本次动画的动画线性（默认为ease） http://cubic-bezier.com/#.17,.67,.83,.67 生成过渡线性（贝塞尔曲线）说明:动画线性的其他值linear： 线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)ease： 平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)ease-in： 由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)ease-out： 由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)ease-in-out： 由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)这里注意如果transition: all 1s 1s ease加在element:hover触发的时候就只会执行一次动画 加在element的时候会执行两次动画 九、2D转换 所有2D转换都是transform属性，只不过后面的值不一样 transform: translate 2D转换中的位移–translateX(20px) 向X轴正方向移动20px–translateY(20px) 向Y轴正方向移动20px transform: scale 2D转换中的缩放–scaleX(1) 延X缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位）–scaleY(1) 延Y缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位） transform: rotate 2D转换中的旋转–rotate(360deg) 旋转一定的角度（即在Z轴上旋转，正值为顺时针，负值为逆时针）注意:transform-origin:top right;绕具体位置旋转(值可以为坐标单词和具体的像素值) transform: skew 2D转换中的倾斜（扭曲）–skewX(360deg) 顺着X轴进行倾斜（不常用）–skewY(360deg) 顺着Y轴进行倾斜（不常用）注意:transform:translatex(x); transform:translatex(y); 上面这样写法,后面会覆盖前面的,当两个都要写的时候就这样写transform:translatex(x) translatex(y); 十、3D转换 transform: translate 3D转换中的位移–translateX(20px) 向X轴正方向移动20px–translateY(20px) 向Y轴正方向移动20px–translateZ(20px) 向Z轴正方向移动20px transform: rotate 2D转换中的旋转–rotateX(360deg) 旋转一定的角度（延X轴进行一定的角度旋转）–rotateY(360deg) 旋转一定的角度（延Y轴进行一定的角度旋转）–rotateZ(360deg) 旋转一定的角度 ( 延Z轴进行一定的角度旋转 )注意:transform:rotate3d(1,1,1,45deg)前面三个一 正的正着转 负的反着转 transform-origin: left bottom 改变旋转轴的位置 第一个参数可以为 top bottom left right 第一个参数可以为 top bottom left right 这里的参数还可以设置像素值 transform-style: preserve-3d 设置在父级盒子上，让其子元素在3D效果下 perspective: 600px 进行600px距离的透视效果，距离越大效果越不明显 注意:我们可以同时使用多个转换，其格式为：transform: translate() rotate() scale() …等，其顺序会影转换的效果。 当在设置动画的时候如果元素本身设置了transform的属性时 如translate() rotate(); 那么在hover的时候要与元素本身的transform属性一一对应顺序才能正确的显示 具体例子如:.rocket { height: 190px; width: 100px; position: absolute; bottom: 0; transform: translate(0, 0) rotate(30deg) ; transition: transform 1s; } section:hover .rocket{ transform:translate(1000px, -500px) rotate(900deg) ; } 十一、帧动画 @keyframes 名字{} 是指动画的定义阶段，里面会写明动画在各个阶段会变换成什么样子–{ from{ from中如果不设置,默认使用的是,初始状态 } to{ to中设置的是结束时的状态 } }–{ 0%{0%中如果不设置,默认使用的是,初始状态 } 50%{50%中设置的是动画中50%帧位置时的动画，当然也可以写的更加细致 } 100%{100%中设置的是结束时的状态 }} animation-name: 名称; 与我们定义动画的时候名字配套，是指我们本次动画使用我们定义的哪一个动画 animation-duration: 2s; 持续时间，是指我们的本次动画要多少时间完成 animation-delay: 2s; 延迟时间，是指我们的本次动画在最开始的时候延迟多少时间后开始 animation-iteration-count: infinite; 执行次数，是指本次动画执行多少次，infinite为无限 animation-timing-function: linear; 是指动画执行的线性(step(5)分布执行) animation-fill-mode: forwards; 是指动画结束时的状态–backwards：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后回到最原始状态–forwards：动画从最原始状态开始，而不是第一帧，动画结束后就留在最后的状态–both：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后就留在最后的状态 animation-direction: normal; 是指动画执行的顺序，在多次执行动画时设置–normal 是指每次动画都是正向执行–reverse 是指每次动画都是反向执行–alternate 是指多次动画时以正向开始，并以（正、反、正…）的顺序执行下去–alternate-reverse 是指多次动画时以反向开始，并以（反、正、反…）的顺序执行下去 animation-play-state: running; 是指动画的暂停与播放–running 是指动画播放–paused 是指动画暂停(用js暂停动画dom.style.animationPlayState=’paused’;) 连写习惯:名称 持续时间 线性 次数 顺序 结束状态 运动和暂停连写注意: 复合写法1属性的顺序是可以随意调换的 2第一次出现的时间是动画持续时间 3第二个出现的时间是延迟时间 4如果只设置一个时间 默认就是动画持续事件 十二、flex弹性盒子 display: flex 设置在父级盒子上，表示开启弹性布局，开启后其子元素会拥有一个主轴，一个侧轴，主轴默认是X轴方向是从左向右，侧轴垂直于主轴，默认方向是从上向下 justify-content: flex-start; 设置在父级盒子上，表示主轴方向上的分布排列–flex-start 这是默认值，是从开始位向结束位依次排列–flex-end 是从结束位向开始位依次排列–center 是居中显示–space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等–space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍说明:space-between 左右靠边,中间间歇相等排布,父盒子的宽度减去所有子盒子的宽度除以(盒子-1)让左右盒子的靠边,其他盒子中间就插上刚刚所算出来的值space-around左右间歇相等 父盒子的宽度减去所有自盒子的宽度再除以所有盒子*加在每个盒子的两侧 align-items: stretch; 设置在父级盒子上，表示对侧轴方向上的分布排列，这是在只有一行的时候使用–stretch 表示其下的子盒子会在侧轴上进行拉伸至上下顶格，会和我们元素本身的宽和高有冲突–flex-start 排在开始位–flex-end 排在结束位–center 是居中显示 align-content: flex-start; 设置在父级盒子上，表示对侧轴方向上的分布排列，这是在多行的时候使用(注意当只有一行的时候无法生效)–flex-start 是从开始位向结束位依次排列–flex-end 是从结束位向开始位依次排列–center 是居中显示–space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等–space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍 flex-direction: row; 改变主轴的方向–row 是默认值，是主轴从左到右的方向排列,开始位在最左侧–column 是主轴从上到下的方向排列，开始位是最上方–row-reverse 是主轴从右到左的方向排列,开始位在最右侧–column-reverse 是主轴从下到上的方向排列，开始位是最下方 flex-wrap:nowrap; 是否允许换行–nowrap 是不允许换行，是默认值–wrap 是允许换行 align-self: flex-start; 设置在子盒子上，是表示当前元素在当前侧轴上所处的位置–flex-start 排在开始位–flex-end 排在结束位–center 是居中显示 order: 1; 设置在子元素上，表示子元素的顺序，按照从大到小的顺序排列，不写的话默认为1 flex: 1; 设置在子元素上，表示子元素在父盒子中主轴方向上所占的比重 零碎知识点: -webkit-user-select:none;设置某元素的文字不能被选中. 实现自定义三角形.box { height: 0; width: 0; border: 50px solid; border-color: yellow transparent transparent transparent; margin: 50px auto} position:absolute;top:0;left:0;right:0;bottom:0;相当于height:100%;width:100%;但是元素必须加绝对定位 backface-visibility:hidden;后面隐藏","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"事件冒泡和捕获","slug":"事件冒泡与捕获","date":"2017-02-25T14:39:04.000Z","updated":"2019-04-26T06:56:01.000Z","comments":true,"path":"2017/02/25/事件冒泡与捕获/","link":"","permalink":"http://yoursite.com/2017/02/25/事件冒泡与捕获/","excerpt":"","text":"##事件冒泡和捕获 事件冒泡当一个元素接收到事件的时候，会把他接收到的事件传给他的父级，一直到顶层window，事件冒泡机制。 事件冒泡阻止e.cancelBubble = true;//阻止当前对象的当前事件冒泡 e.stopPropagation(); 开启事件捕获element.addEventListener(eventName,handler,true)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"html5基础一","slug":"html5第一天","date":"2017-02-23T13:18:45.000Z","updated":"2019-04-26T06:58:17.000Z","comments":true,"path":"2017/02/23/html5第一天/","link":"","permalink":"http://yoursite.com/2017/02/23/html5第一天/","excerpt":"","text":"###1，严格模式strict.dtd。 在js开头处加”use strict”;就成为严格模式 ###2，var fra = document.createDocumentFragment();创建文档碎片。 document.body.appendchild(fra); ###3，cc:ie6（ie专用注释） ###4，自执行函数(function(){})(); ###5，itemscope(那个元素设置了这个属性，就把他当做一个整体)itemprop等 6，guoxiang1991.github.io 7， 课程： php8，广告页必须要小，就可以用到html5的dom操作。9，html5表单：9.1 fieldset 元素可将表单内的相关元素分组9.2 legend标签为 、 以及 元素定义标题。9.3 required 必填项。9.4 multiple 属性规定输入域中可选择多个值。9.5 autofocus 默认获取焦点。9.6 placeholder 占位符。9.7 pattern 自定义验证。9.8 min 最大值。9.9 max 最小值。9.10 progress进度条9.11 meter 度量器 使用范列 入学成绩: 基础水平: var score = document.getElementById(“score”); var level = document.getElementById(“level”); score.oninput = function () { level.value=this.value; }9.12 所属学院: 10，音乐添加 autopaly(自动播放 controls 是否显示默认播放控件 loop循环播放)多浏览器支持方案 11，视频添加 autoplay 自动播放controls 是否显示默认播放控件loop 循环播放width 设置播放窗口宽度height 设置播放窗口的高度（查询浏览器支持情况）多浏览器支持的方案 12，语义化标签header头部container主体部分article文章aside侧旁栏footer底部section区块 13，表单元素 数据列表 生成加密字符串 输出结果 0度量器 14，兼容处理：在不支持HTML5新标签的浏览器里，会将这些新的标签解析成行内元素（inline）对待。所以我们只需要将其转换成块元素即可使用。但是在IE9版本以下，并不能正常解析这些新标签，但是却可以识别通过document.createElement(‘tagName’)创建的自定义标签，于是我们的解决方案就是将HTML5的新标签全部通过document.createElement(‘tagName’)来创建一遍，这样IE低版本也能正常解析HTML5新标签了，但在实际开发中我们更多采用的是通过检测IE浏览器的版本来加载第三方的一个JS库来解决兼容问题，这个库文件会帮自动通过document.createElement(‘tagName’)创建所有HTML5的新标签。 15，微数据 刘德华 2012年2月6日 22:30 http://www.baidu.com 评论内容 dom1，document.querySelector(‘selector’)通过CSS选择器获取元素，符合匹配条件的第1个元素。 2，document.querySelectorAll(‘selector’) 通过CSS选择器获取元素，以伪数组形式存在。 3，类名操作1、Node.classList.add(‘class’) 添加class2、Node.classList.remove(‘class’) 移除class3、Node.classList.toggle(‘class’) 切换class，有则移除，无则添加4、Node.classList.contains(‘class’) 检测是否存在classNode指一个有效的DOM节点，是一个通称。5，自定义属性假设某元素var demo = document.querySelector(‘#demo’);1、读取 demo.dataset[‘name’]2、设置demo.dataset[‘name’] = ‘web developer’","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"html5表单","slug":"html5表单","date":"2017-02-21T14:55:22.000Z","updated":"2019-04-26T06:20:45.000Z","comments":true,"path":"2017/02/21/html5表单/","link":"","permalink":"http://yoursite.com/2017/02/21/html5表单/","excerpt":"","text":"HTML5的表单 HTML5的第二个大特点就是他的各种表单控件，也是非常强大的功能。 输入类型 输入类型，顾名思义就是我们在写input标签时type后面的属性值，我们以前接触的有 &lt;input type=&quot;text&quot;&gt;//-&gt; 文本框 &lt;input type=&quot;password&quot;&gt;//-&gt; 密码框 &lt;input type=&quot;checkbox&quot;&gt;//-&gt; 复选框 &lt;input type=&quot;radio&quot;&gt;//-&gt; 单选框 &lt;input type=&quot;submit&quot;&gt;//-&gt; 提交 &lt;input type=&quot;button&quot;&gt;//-&gt; 按钮 &lt;input type=&quot;reset&quot;&gt;//-&gt; 重置 &lt;input type=&quot;file&quot;&gt;//-&gt; 文件选择 这些都是我们以前的输入类型，但是对于今天的开发，这些类型已经不够用了，我们需要更多更细致的分类 &lt;input type=&quot;email&quot;&gt;//-&gt; email地址匹配 &lt;input type=&quot;url&quot;&gt;//-&gt; url地址匹配 &lt;input type=&quot;tel&quot;&gt;//-&gt; 电话号码 &lt;input type=&quot;number&quot;&gt;//-&gt; 数字 &lt;input type=&quot;search&quot;&gt;//-&gt; 搜索框 &lt;input type=&quot;color&quot;&gt;//-&gt; 拾色器 &lt;input type=&quot;time&quot;&gt;//-&gt; 时间选择 &lt;input type=&quot;date&quot;&gt;//-&gt; 日期选择 &lt;input type=&quot;month&quot;&gt;//-&gt; 月份选择 &lt;input type=&quot;week&quot;&gt;//-&gt; 周选择 这些新加入的输入类型，大大的降低了我们的代码量。比如，email框，以前我们要是想让这个框里输入的一定是email地址的话，我们需要用JS获取这个input框的value，然后写一段正则来匹配，最后在返回结果。而现在我们只需要在HTML中写个email类型的input框就可以了。 当然了，这里面有一些是针对移动设备的，并且有兼容性问题，所以我们在开发过程中一定要根据需求选择性的来使用。 表单元素 表单元素其实就是HTML5中新增加的一些属于表单的新标签。 以前我们接触的表单元素有 &lt;form&gt;&lt;/form&gt;//-&gt; 表单 &lt;fieldset&gt;&lt;/fieldset&gt;//-&gt; 表单框 &lt;legend&gt;&lt;/legend&gt;//-&gt; 表单框的标题 &lt;label&gt;&lt;/label&gt;//-&gt; 表单里的控件标签 &lt;textarea&gt;&lt;/textarea&gt;//-&gt; 文本区域 &lt;select&gt;&lt;/select&gt;//-&gt; 选择列表 &lt;option&gt;&lt;/option&gt;//-&gt; 选择列表的下拉项 下面是我们HTML5中新增加的表单元素&lt;datalist&gt;&lt;/datalist&gt;//-&gt; 数据列表 &lt;output&gt;&lt;/output&gt;//-&gt; 输出结果 &lt;meter&gt;&lt;/meter&gt;//-&gt; 度量器 &lt;keygen&gt;&lt;/keygen&gt;//-&gt; 生成加密字符串 这些都是为了我们的开发效率更快而诞生的，大家只需要记住就好。 表单属性 表单属性就是对于一些表单元素的修饰，因为光靠现在的表单输入类型加上现有的表单元素，还是不能满足我们的各式各样的需求，所以就需要在依靠表单属性来帮我们做一些小细节的处理。 比如：我们要一个文本框只能输入数字，以前只能靠一小段JS代码来实现，现在可以直接用“input type=”number””就可以了，但是如果我只想让他输入10到20之间的数字的时候，就必须要表单属性来帮助了。 &lt;input type=&quot;number&quot; min=&quot;10&quot; max=&quot;20&quot;&gt; 这样的话就只能填写10到20之间的数字了。 以前我们还接触过很多表单属性，比如value等，我们就不意义列举了，直接介绍一下HTML5新增的属性 placeholder//-&gt; 占位符 autofocus//-&gt; 自动获取焦点 multiple//-&gt; 多文件上传 autocomplete//-&gt; 自动填充 form//-&gt; 表单关联 novalidate//-&gt; 关闭验证 required//-&gt; 必填 pattern//-&gt; 自定义验证 通过这些表单属性，我们可以在HTML页面更加细致的处理一些表单的细节，而不需要借助JS。做到了节约性能。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"html5兼容性","slug":"html5标签兼容性","date":"2017-02-21T14:32:13.000Z","updated":"2019-04-26T06:21:30.000Z","comments":true,"path":"2017/02/21/html5标签兼容性/","link":"","permalink":"http://yoursite.com/2017/02/21/html5标签兼容性/","excerpt":"","text":"##HTML5的兼容性 因为在IE8及一下的IE版本是不兼容HTML5的新元素的，所以我们要是用HTML5开发的话，第一个要解决的就是兼容性的问题。HTML5的兼容性 因为HTML5的新元素就是一些新的标签，IE只是不认识这些标签而已，那我们解决的问题就是让IE8一下版本的浏览器认识这些标签，或者说知道他就是一个标签，那么我们就解决了兼容性问题。比如：header 这个标签在IE8及一下的版本的浏览器中是不认识的，但是我们却可以通过一小段JS代码来创建标签，通过JS来创建的标签浏览器是可以识别的，我们就可以利用这个点来解决兼容性问题。这里就需要用到一个方法，document.createElement(); var oHeader = document.createElement(&quot;header&quot;);//-&gt; 动态创建一个标签‘header’document.body.appendChild(oHeader)//-&gt; 把header标签动态添加到body中这样添加以后我们就可以在IE8下使用header标签了。但是，我们不确定我们的每一次开发中到底使用多少个header标签，也不确定具体要什么时候使用，如果说我们每一次使用的时候都写一小段JS代码来动态创建和动态添加的话，那就会很耗性能，所以我们只需要在最开始告诉浏览器一声，我创建了一个header标签就可以，至于什么时候用浏览器你就别管了，反正只要出现了这个标签你知道他是什么，会渲染他就可以了，我们就可以这样写 document.createElement(&quot;header&quot;);这样就可以了，以后你再使用header标签的时候，浏览器就会知道，他是一个标签，我就按照标签的标准来渲染他就行了。但是第二个问题出现了，那就是我们也不知道我会在这次开发中都使用到哪些个HTML5的标签，那么我们就把每一个HTML5标签都声明一遍就可以了。 这里就不用我们自己来写了，只需要引入一个JS文件就可以了。就是 “html5shiv.min” 这个文件，里面已经帮我们把所有的都写好了，就不用我们每回自己写了。这个时候出现了第三个问题，那就是我们引入了这个JS文件以后，那么不管这个浏览器是不是兼容HTML5标签，我们都声明了一遍，也就是说我们这一段JS代码都运行了，当然，这样做是没有问题的，可是这样对于已经可以兼容HTML5的浏览器来说就是浪费了，虽然这个文件很小，但是也会浪费一定的性能，作为一个开发人员来说，没一个KB的性能都是能省就省，尽量不出现一个多余的KB。所以，我们就只要让这个JS文件在IE8及以下版本的浏览器中运行就行了，这个时候我们就需要一种方法： 这个注释的意思是，当浏览器是IE8及以下的版本的时候，才执行中间的代码。 只有在IE8及一下版本的浏览器中，才会执行这个“alert(123)”这个命令，而其他的浏览器不会执行这一段代码。 所以我们可以用这个方法来引入刚才那段JS代码 这样就可以做到只在不兼容HTML5的浏览器中进行声明，而兼容的浏览器则直接跳过，这样做即解决了兼容性问题，也进行了性能优化。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"兼容性","slug":"兼容性","permalink":"http://yoursite.com/tags/兼容性/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"angular路由使用","slug":"angular路由使用","date":"2017-02-21T08:00:45.000Z","updated":"2019-04-26T06:21:56.000Z","comments":true,"path":"2017/02/21/angular路由使用/","link":"","permalink":"http://yoursite.com/2017/02/21/angular路由使用/","excerpt":"","text":"angular路由使用安装angular-route npm install angular-route –save引用模块 &lt;script src=&quot;node_modules/angular-route/angular-route.js&quot;&gt;&lt;/script&gt;创建模块 var app = angular.module(&#39;myApp&#39;,[&#39;ngRoute&#39;]); 使用规则 //有一个参数：类似于controller的第二个参数 //需要注入一个参数$routeProvider 这个参数是用来设置具体的规则的 app.config([‘$routeProvider’,function($routeProvider){ // 路由参数： // when方法，第一个参数是当前url中锚点值 // 第二个参数是一个object对象 并且可以通过.实现链式编程 从而实现多个筛选（不过一般使用路由参数动态的实现筛选） // 当我们满足这样的规则的时候就会把模板的内容插入到页面插入有ng-view属性的标签的innerHTML //路由参数’/students/:name?’这里加?（0-1）个参数 让参数可控 当/后面没有内容的时候也走这个规则 $routeProvider.when(&apos;/students/:name?&apos;,{ //模板 template/templateUrl template:&apos;&lt;p&gt;{{nowStu.id}},{{nowStu.name}},{{nowStu.grade}}&lt;/p&gt;&apos;, // 指向一个控制器的名字 最终我们需要在这个模板中使用一些数据模型 controller:&apos;stuController&apos; //otherwise 当上面的when都没有匹配的时候 就走这里面 需要一个参数 是一个对象 }).otherwise({ //当前面所有的when都不满足时 就会跳转到这个指定的锚点值页面 redirectTo:&apos;/students/&apos; }) //创建控制器 //控制器暴露的数据能够在template中使用 //$routeParams是一个对象 获取url中想要匹配的值 如 {name:&quot;zhangsan&quot;} //$route监视url参数的变化 app.controller(&apos;stuController&apos;,[&apos;$scope&apos;,&apos;$routeParams&apos;，&apos;$route&apos;,function($scope,$routeParams,$route){ $scope.students = { zhangsan: {id: 0, name: &quot;张三&quot;, grade: &quot;一年级&quot;}, lisi: {id: 1, name: &quot;李四&quot;, grade: &quot;一年级&quot;}, xiaobai: {id: 2, name: &quot;小白&quot;, grade: &quot;一年级&quot;}, wangwu: {id: 3, name: &quot;王五&quot;, grade: &quot;一年级&quot;}, zhaosi: {id: 4, name: &quot;赵四&quot;, grade: &quot;一年级&quot;}, } //动态暴露数据 为了让路由中的模板使用 $scope.nowStu = $scope.students[$routeParams.name]; //当用户输入的数据没有的时候就会默认跳转到摸个数据上进行显示 if($scope.nowStu){ //$scope.nowStu=$scope.students[&apos;lisi&apos;]; //$route提供一个方法 默认会跳转到lish的信息 //updateParams他只能改&apos;/students/:name?&apos;中name的值 $route.updateParams({name:&apos;lisi&apos;}); //如果要改urL整个的值 需要使用$location.url(&apos;/sunyu/&apos;) 但是注意$location.url获取的锚点值不包括# $location.url(&apos;/sunyu/&apos;)； } }]);","categories":[],"tags":[],"keywords":[]},{"title":"npm browser gulp使用","slug":"npm browser gulp使用","date":"2017-02-18T08:47:55.000Z","updated":"2019-04-26T06:26:52.000Z","comments":true,"path":"2017/02/18/npm browser gulp使用/","link":"","permalink":"http://yoursite.com/2017/02/18/npm browser gulp使用/","excerpt":"","text":"流行框架第2天sourceTree , tortoiseGitnpm 官网[https://www.npmjs.com] node package manager 命令: 初始化:npm init 安装指定包:npm install jquery --save 安装指定包:npm install jquery@版本号 --save 删除指定包:npm remove jquery --save 下载安装package.json中dependencies属性对的文件:npm install --production browser-sync 更改代码之后自动刷新浏览器 需要使用npm进行全局安装:npm install browser-sync -g,-g表示安装到全局 使用:browser-sync start --server --files &quot;./index.html,app.css,./css/*.css,*.*&quot; ``z注意这里父文件和子文件都不要用中文 后面指定文件用双引号 –files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。 gulp 官网 中文网 前端自动化构建工具js压缩,var x,xname，混淆合并.css压缩html压压缩 grunt ,webpack… 核心就5个方法 task,gulp中是一个个任务的形式来实现功能。 task(‘任务名’,function(){…..}); src src(‘./*.js’) dest(‘./minjs/‘)// 指定处理后的文件的输出路径. watch(‘./*.js’,[‘任务名1’,’任务名2’]); run(‘任务名’);//执行指定的任务. gulp的安装 使用npm 进行安装 npm install gulp-cli -g; gulp 使用使用时还需要在项目中通过npm非全局安装gulp npm install gulp --save-dev 还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.gulp的一些插件 也是使用npm安装 对js代码进行压缩 gulp-uglify 对代码进行合并 gulp-concat 对css进行压缩 gulp-cssnano 对html进行压缩 gulp-htmlmin","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"git","slug":"git","date":"2017-02-18T06:41:33.000Z","updated":"2019-04-26T06:24:59.000Z","comments":true,"path":"2017/02/18/git/","link":"","permalink":"http://yoursite.com/2017/02/18/git/","excerpt":"","text":"Git什么是Git? Git是一款源代码管理工具(版本控制工具) 我们写的代码需要使用Git进行管理。1.0是稳定2.0加了新功能 源代码有必要管理起吗？ 有必要，因为人工的去处理不同的版本，做相应备份会很麻烦。 svn,vss,vcs,tfs…..-Git是linux之父当年为了维护linux—linus之前也是手动维护合并把文件发给Linus BitKeeper(收费) 有人想破解(不给提供免费使用) linus自己写了一个版本管理的工具（Git） 分布式版本管理工具，集中式 git属于分布式 svn集中式 git安装git初始化一个仓库 其实就是创建了一个.git隐藏目录 命令:git init; 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令. 一般是在项目的根目录执行这个命令. 自报家门 配置用户名 : git config user.name &quot;testName&quot; 配置全局用户名 : git config --global user.name &quot;testName&quot; 配置邮箱 : git config user.email &quot;test@sina.com&quot; 配置邮箱 : git config --global user.email &quot;test@sina.com&quot; 查看配置信息: git config --list 把代码提交到仓库中 1.先把代码添加到暂存区(就相当于放到仓库门口) 命令:git add 文件路径/文件名 示例:git add ./reademe.md 可以使用git add .这个命令，批量把当前目录下所有修改过的文件添加到暂存区。 2.把暂存区的文件提交仓库里 命令: git commit -m &quot;注释&quot; 示例: git commit -m &quot;我们添加了一个新的功能&quot; -m 表示指定一个字符串，作为提交的说明(相当于注释); 合并add 与commit 命令 git commit -a -m &quot;这是使用合并添加与提交的操作&quot;; 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用) 查看工作区状态 命令:git status 添加忽略文件 在项目中有一些文件是不需要提交的,我们需要把它忽略掉 需要在.git文件夹所在目录新建一个名为.gitignore的文件然后在这个文件中写上需要被忽略的文件的路径。示例: /css/a.css: /css/*.css : /a.html 比对文件差异 命令: git diff 用来比较暂存区文件内容与工作区文件内容的区别 如果暂存区没有文件，就会将工作与代码与最近一次提交对比 命令：git diff --cached 比较暂存区的文件和仓库中文件的区别 对比之前某两次提交的文件的差异 命令:git diff [版本号1] [版本号2] [想比较的文件路径] 查看日志 命令:git log,可以查看每一次提交的日志 命令:git log --oneline 表示使用简洁的形式输出提交日志 版本回退 命令:git reset --hard Head~1 这是将代码回退到上上一次提交时的状态 命令:git reset --hard Head~2 回退到上上上次 命令:git reset --hard Head~0 回退到上次提交时的状态,~0可以省略 命令:git reset --hard 版本号 通过每次提交时生成的版本号来回退版本 通过git reflog命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。 创建分支 命令:git branch [分支名] 创建一个新分支 命令:git branch 查看当前所有的分支 切换分支 命令:git checkout [分支名] 切换分支后可以在切换后的分支中进行正常的操作 合并分支 命令:git merge [分支名] git会将指定的分支合并到当前分支. 删除分支 命令:git branch -d [分支名] 删除指定分支，-d参数表示要执行删除操作 git提交中的冲突 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交 githubgithub与git git 版本管理工具 github 就是一个网站，只是这个网站提供git服务器的功能 上传代码到git服务器(push) 命令:git push [远程服务器地址] [远程服务器的分支] 示例:git push https://github.com/huoqishi/test002.git master 上传时可以使用一些简化的命令 将远程服务器地址写成变量的形式 git remote add [变量名] [远程服务器地址] 示例:git remote add origin https://github.com/huoqishi/test002.git 这样之后就可以直接使用origin来代替git push 后面写的地址了git push origin master 还可以尽一步简化 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了git push origin; git使用ssh方式上传代码与github git生成公钥和私钥 命令:ssh-keygen -t rsa生成的公钥与私钥文件会在当用户目录的.ssh目录下. 把代码push到服务器时需要先pull一下 在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。 从服务器上pull代码到本地 如果本地没有.git目录，需要先初始化一下。 命令:git pull [远程服务器地址] [远程的分支] gh-pages分支-搭建博客. 需要把自已博客的网页代码上传到github上的gh-pages分支 然后就直接访问了 访问的url形式: [github用户名].github.io/[仓库的名字]/[具体的页面]","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"正则","slug":"正则表达式","date":"2017-02-12T15:11:44.000Z","updated":"2019-04-26T06:27:49.000Z","comments":true,"path":"2017/02/12/正则表达式/","link":"","permalink":"http://yoursite.com/2017/02/12/正则表达式/","excerpt":"","text":"##正则表达式 ####RegExp对象创建的方法 new RegExp(&quot;a&quot;,&quot;i&quot;); //后面的i就是忽略字母大小写。 /a/i //后面的i就是忽略字母大小写。 g全局 +0个或者多个 | 或者 [a,b,c] a或者b或者c [0-9]数字 [a-z]字符 [0-9a-z]数字字符 [^a]除了a + 1个或者多个 ？0个或者1个 *0或者多个 \\转移符","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"less基础语法","slug":"less使用","date":"2017-02-10T02:55:16.000Z","updated":"2019-04-26T06:06:58.000Z","comments":true,"path":"2017/02/10/less使用/","link":"","permalink":"http://yoursite.com/2017/02/10/less使用/","excerpt":"","text":"less语法一、注释的区别/**/会编译在css文件中 //不会编译在css中 二、声明变量及使用@maincolor:#92322; 使用变量 body{ color:@maincolor;} 三、mixin混入.redFont{ color:red; } .redBorder { border:1px solid red; } //红色文字和边框 通过class混合 .redFontBorder-class { .redFont(); .redBOrder(); } //方法 .redFont-func(){ color:red; } .redBorder-func(){ border:1px solid red; } //红色文字和边框 通过func混合 .redFontBorder-func{ .redFont-func(); .redBorder-func(); } 四、嵌套#header{ width:100px; &gt;div{ width:100px; p{ width:100px; &amp;:hover { width:100px; } } &amp;+div { width:100px; } //&amp;~div { width:100px; } } } 直接写在里面就是 后代选择器 &amp;：hover &gt; 子代选择器 &amp;+ 加号选择器 &amp;~ 波浪选择器 五、导入@import注意这里引入less文件的时候不用加后缀名 如: @import &quot;文件名&quot;； 可以使用引入文件的变量和函数以及类名。 六、运算颜色运算 @red:red*0.5; 内置函数 @gary:darken(#333,10%); 七、less的使用引用less文件 注意在引用的时候文件类型写type/less 引用less.js文件(在浏览器上使用less，我们需要添加一个js插件 less.js 解析less文件动态加载 注意：他是一部加载less文件 然后解析 一定要求是 使用http形式访问 否则无法加载less文件 不建议使用less.js这种形式来用less","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css预处理器","slug":"css预处理器","permalink":"http://yoursite.com/tags/css预处理器/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"canvas基础三","slug":"canvas第三天","date":"2017-01-09T14:51:28.000Z","updated":"2019-04-26T07:29:16.000Z","comments":true,"path":"2017/01/09/canvas第三天/","link":"","permalink":"http://yoursite.com/2017/01/09/canvas第三天/","excerpt":"","text":"#### 图片绘制 创建图片元素 document.createElement( ‘img’ ) var img = new Image(); img.src = ‘’;资源图片的路径。 ctx.drawImage() 有三种调用形式 1&gt; ctx.drawImage( img, x, y ) 将 image 绘制到 x, y 表示的位置 2&gt; ctx.drawImage( img, x, y, width, height ) 将 img 绘制到一个矩形区域内 说明，前面的x，y为绘制起始的位置，后面的width和height是图片显示的大小。 这里可以使x,y加一个数字实现叠图的效果。 3&gt; ctx.drawImage( img, sx, sy, sw, sh, x, y, w, h )将图片 img 的 sx, sy, sw, sh 部分的内容绘制到画布的x, y, w, h 的矩形区域内. 说明sx,sy是资源图片的起始位置，sw,sh资源图片的宽高，x,y目标显示起始坐标，目标显示宽高。 计时器模型 var id = setInterval(function () { if ( 条件 ) { clearInterval( id ); } // 继续执行我的内容 }, 20); 知识点：ctx.clearRect( 0, 0, cas.width, cas.height );擦除整个画布。 动画：核心代码参考 &lt;script&gt; function toAngle( radian ) { return radian * 180 / Math.PI; } function toRadian( angle ) { return angle * Math.PI / 180; } var cas = document.getElementById( &apos;cas&apos; ); var ctx = cas.getContext( &apos;2d&apos; ); var img = new Image(); img.src = &apos;NPCrabbitbaby-2.png&apos;; img.onload = function() { var width = img.width / 4; var height = img.height / 4; var i = 0; setInterval(function() { ctx.clearRect( 0, 0, cas.width, cas.height ); ctx.drawImage( img, i*width,0,width,height,100,100,width,height); if ( i == 3) { i = 0; } else { i++; } },200); } 变换的概念 计算机绘图是利用坐标进行绘图. 绘制任何图形都和坐标系的结构息息相关. 所谓的变换就是一套数学公式, 可以记录坐标轴的变化方式. 利用坐标轴的变换可以绘制出, 根据不同坐标轴特点而形成的图形. 基本的 api ctx.translate(x,y) 平移变换 ctx.rotate(reg) 旋转变换 ctx.scale(x,y) 伸缩变换 封装绘图对象 Line Rect Circle x, y, radius, strokeStyle, fillStyle, lineWidth Arc function Line( config ) { } Line.prototype = { stroke: function () { } } canvas 的状态 在 Canvas 中凡是设置了属性效果, 都会延续到后面一次修改 Canvas 在创建出来的时候, 是有一个默认的状态的 我希望每次修改状态的时候 都是不影响原来默认状态的 每次画完图时, 我都会新建一个状态, 然后绘制完成后 恢复到原有状态 ctx.save() 将当前状态保存 ctx.restore() 将保存的状态恢复 状态栈 在 canvas 绘制的时候允许使用 canvas 绘制 canvas ctx.darwImage( img, … ) 此时 img 可以是 图片, 还可以是 canvas, 甚至是 video Konva 是一个完全面向对象的框架 将所有的东西都看做是对象: 图片, 直线, 矩形, … 将整个canvas看做成舞台(stage) 在舞台上放一个层, 那么将所有的图形放在这个层中 命名空间 var num = 123; function foo() {} // 污染全局作用域 var Itcast = {}; Itcast.num = 123; Itcast.foo = function () {}; 获取当前字体大小的情况下某些文字占用的宽度和高度 ctx.font = “20px”; var obj = ctx.measureText(“你好”); obj.width obj.height 在canvas里面绘制图片： A.创建一个图片对象 var img = new Image();//创建一个图片对象 img.src = ‘1.jpg’; B.等图片对象加载完成以后，将图片对象绘制到canvas里面去 //等待img对象加载完成以后，执行函数 img.onload = function(){ //1.将图片绘制到canvas里面的坐标0，0处 ctx.drawImage( img , 0 , 0 ); //2.将图片绘制到canvas里面的坐标0,0处，并且图片大小为width,height ctx.drawImage( img , 0, 0, width, height); //3.将图片img的sx,sy坐标处的sw,sh大小的图片区域绘制到canvas里面的x,y坐标处的大小为w,h //的区域中 ctx.drawImage( img , sx,sy,sw,sh, x,y,w,h); } 变换的概念：我们现在的canvas绘图都是通过坐标来进行绘制。所谓的坐标就是canvas坐标系中的一个点。canvas的坐标系可以通过变换来进行改变，当canvas的坐标系发生了改变的时候，坐标点也会跟着发生改变。最后我们可以通过变换来画出一些比较好看的图形。 变换的api方法： A.translate(x,y);//平移变换， B.rotate(deg);//旋转坐标系，旋转deg度 C.scale(2,0.5);//缩放变换, x轴放大2倍，y轴缩小一半","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"canvas基础二","slug":"canvas第二天","date":"2017-01-09T12:18:33.000Z","updated":"2019-04-26T06:46:49.000Z","comments":true,"path":"2017/01/09/canvas第二天/","link":"","permalink":"http://yoursite.com/2017/01/09/canvas第二天/","excerpt":"","text":"1. 绘制折线图假设有点: ( 10, 20 ), ( 15, 13 ), ( 17, 30 ), ( 30, 10 ), ( 20, 15 ) 将这些点绘制到坐标轴中. 2. 绘制形状-&gt; 矩形 ctx.rect( x, y, width, heigth ) 描边, 需要 stroke 或 fill ctx.strokeRect( x, y, w, h ) ctx.fillRect( x, y, w, h ) ctx.clearRect( x, y, w, h ) 清除该矩形区域的内容 -&gt; 清除整个画布 ctx.clearRect( 0, 0, cas.width, cas.height ); cas.width = cas.width; -&gt; 圆弧 ctx.arc( x, y, r, startAngle, endAngle, clockwise ) ctx.arcTo() 了解 参数:x,y圆心 r半径，startAngle起始弧度，endAngle结束弧度，clockwise画圆方向（顺时针或者你时针） -&gt; 圆 ctx.arc( x, y, r, 0, 2 * Math.PI ) 3. 弧度制为了更好的计算角度, 我们该角度提供一个新的定义, 用 PI 作为单位 将单位圆的一个整圈( 360 度 )记作 2 倍 的 PI. 这样的度量表示就是弧度制的表示方法. 60 度 PI / 3 45 度 PI / 4 30 度 PI / 6 学会进行转换 2 PI 刚好是一圈 一圈又是 360 度 2 PI 比上 360 度 = 弧度 比上 对应的角度 angle 角度 radian 弧度 function toAngle ( radian ) { return radian * 180 / Math.PI; } function toRadian ( angle ) { return angle * Math.PI / 180; } 4. 角度的坐标水平向右的角度是 0 度, 或 0 弧度 顺时针是正方向, 逆时针是负方向 练习: 绘制出, 圆心在 canva 正中心, 半径为 100, 角度从 -60度 到 120 度的圆弧 5. 如果没有当前位置, 绘制圆弧是没有任何问题但是如果有了当前位置, 绘制圆弧的时候会将当前位置连接到圆弧上 6. 计算在圆弧上的点的坐标7. 根据固定到起始点到 圆心, 结合圆弧和 closePath 方法可以绘制扇形( 楔形 Wedge)8. 动态的通过动画, 一点一点的添加角度, 然后绘制一整个圆9. 绘制文字ctx.fillText( 文本内容, x, y ) ctx.strokeText( 文本内容, x, y ); 常用的属性 ctx.font = &apos;30px 黑体&apos; ctx.textAlign left, center, right. start, end ctx.textBaseline top, middle, bottom. hanging, ideographics, alphabetic ctx.measureText( 文本 ) 获取当前文字的字体设置下, 文字的宽度对象 绘制矩形的方法： A.rect(x,y,width,height);//rect方法只是打草稿，必须配合stroke()或fill()方法来绘制图形 B.strokeRect(x,y,width,height);//绘制空心矩形 C.fillRect(x,y,width,height);//绘制填充矩形。 清除矩形区域： //擦除从x,y坐标开始的矩形区域，这个区域的大小由width，height来决定 ctx.clearRect(x,y,width,height); 清除整个画布的内容： A. ctx.clearRect(0,0,canvas.width,canvas.height); B. canvas.width = canvas.width; 绘制圆弧的方法： A. ctx.arc( 圆心坐标x,圆心坐标y, 圆弧的半径，圆弧开始的弧度,圆弧结束的弧度,圆绘制的方向 ); ctx.arc(100,100,50,0,2*Math.PI,true); ctx.stroke(); B. ctx.moveTo(x0,y0); ctx.arcTo(x1,y1,x2,y2,半径); //从x0,y0的点拉一条线到x1,y1 再从x1,y1拉一条线到x2,y2. //以半径绘制两条线的相切圆。 弧度制：为了能够更好的表示的角度，如果是360度就记做 2*PI 圆弧的0度角在圆心水平向右。0度角顺时针是角度的正方向0独角逆时针是角度的逆方向 当我们绘制圆弧的时候，有一个特性： 会将圆弧的起始点和moveTo的定点连接起来 计算圆弧上坐标点的公式： x = 圆心坐标x + 半径 Math.cos( toRadian(角度)); y = 圆心坐标y + 半径 Math.sin( toRadian(角度)); 绘制扇形的步骤： A.moveTo到圆心 B.绘制圆弧 C.ctx.closePath() 数据饼形图： 绘制文本的方法：A.ctx.fillText(文本字符串,x,y);B.ctx.strokeText(文本字符串,x,y); 注意：绘制的文本字符串会绘制在x,y坐标处，文字内容左下角对齐x,y坐标点。 设置绘制文字的尺寸： ctx.font = “30px 黑体”;设置绘制文字的水平对齐： ctx.textAlign = ‘left’;//left,center,right设置绘制文字的垂直对齐： ctx.textBaseline = “top”;//top,middle,bottom","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"canvas 基础一","slug":"canvas第一天","date":"2017-01-06T13:39:39.000Z","updated":"2019-04-26T07:29:13.000Z","comments":true,"path":"2017/01/06/canvas第一天/","link":"","permalink":"http://yoursite.com/2017/01/06/canvas第一天/","excerpt":"","text":"1.canvas:canvas是一个H5的标签，它相当于是一张“画布”，我们可以在这一张画布上进行绘制。2.canvas默认的大小是宽300px，高150px，宽度和高度可以通过canvas标签的height和width属性进行设置 &lt;canvas width=&apos;600px&apos; height=&quot;300px&quot; &gt; 注意：请不要使用css来设置canvas的宽度和高度 3.如何使用canvas进行绘图，步骤如下：A.获得canvas标签对象： var cas = document.getElementsByTagName(&quot;canvas&quot;)[0]; B.获取canvas标签对应的绘图工具： var ctx = cas.getContext(&quot;2d&quot;); var ctx2 = cas.getContext(&quot;webgl&quot;); var ctx3 = cas.getContext(&apos;experimental-webgl&apos;); C.开始使用绘图工具进行绘制： ctx.moveTo(100,100);//将绘图工具定点在坐标x100，y100的地方 ctx.lineTo(200,100);//将绘图工具从100,100的坐标绘制一条到200,100坐标的线（注意，这里的moveTo和lineTo都是打草稿，必须通过stroke或者fill进行真正的绘制） D.真正的绘制图形： ctx.stroke();//画线 ctx.fill();//填充 4.canvas的坐标系：以canvas画布的左上角作为坐标系的原点原点向右为x的正方向，原点向左为x的负方向 原点向下为y的正方向，原点向上为y的负方向 5.fill方法的特性：当我们使用绘图工具绘制图形的时候，如果绘制图形的时候没有将结束的点（lineTo的最后的那个点）和开始的点进行连接，fill方法会自动将结束的点和开始的点进行连接，然后往图形中进行填充。6.非零环绕原则：判断绘制的图形是否要进行填充的准则。从是否要填充的区域拉出一条辅助线来到图形的外面 如果绘制图形的线穿过辅助线的时候是正方向就记做+1 如果绘制图形的线穿过辅助线的时候是负方向就记做-1 最后把所有记录的值加总，如果值为0这块区域就不填充，如果值为非零，这块区域就要填充。 注意：从左到右为正，从右到左为负。，、 练习：将回字型的图形绘制出来。 7.closePath方法：可以将绘制的图形进行完美的闭合8.api集合：属性： ctx.lineWidth = &quot;10&quot;;//设置绘图工具画的线的宽度为10px ctx.lineCap = &apos;butt&apos;;//可以设置的值：&quot;square&quot;,&quot;round&quot;; ctx.lineJoin = &apos;miter&apos;;//可以设置的值：&quot;round&quot;, &quot;bevel&quot;; ctx.lineDashOffset = 10;//这个属性可以用来设置虚线的缩进 ctx.strokeStyle = &apos;red&apos;;//设置描边线条的颜色 ctx.fillStyle = &apos;blue&apos;;//设置填充的颜色 方法： ctx.moveTo(x,y);//将绘图工具进行定点 ctx.lineTo(x,y);//将绘图工具移动到x，y的坐标 ctx.stroke();//将图形进行描边 ctx.fill();//将图形进行填充 ctx.closePath();//将图形进行闭合 ctx.beginPath();//开启新路径，开启一个新的绘图状态。 ctx.setLineDash(数组);//根据数组来设置实现和虚线的绘制 ctx.getLineDash();//这个方法可以获取一个数组，数组就是设置虚线的数组 9.取消锯齿美化操作：当我们使用canvas进行绘图的时候，为了让图形看起来更加的美观，canvas会做取消锯齿（除了原本绘制的线以外，还会给这根线添加一条更淡颜色的辅助线）。取消锯齿的美化操作会在什么时候发生：设置的线宽为奇数的时候，当你画的线不是一个直线的线（倾斜的线。） 注意：当线宽设置的比较宽了以后，要注意一个事情。线的起始点是从线的线中心开始计算起始点的。 总结：如果要闭合一个图形，请使用closePath方法，不要再用lineTo连线。 10.开启新路径：beginPath()：用来绘制新的图形内容，此时这个图形内容跟之前绘制的图形没有关系。不会造成图形之间的干扰11.绘制虚线：A.ctx.setLineDash(数组);//根据数组来设置实现和虚线的绘制 B.ctx.getLineDash();//这个方法可以获取一个数组，数组就是设置虚线的数组 C.ctx.lineDashOffset = 10;//这个属性可以用来设置虚线的缩进 12.坐标轴的原点转换：x0,y0 : 指的是绘制的坐标系的原点 x,y: 计算出来的坐标点的x,y坐标 var x = (cas.width - paddingLeft - paddingRight - arrowHeight)/2, y = (cas.height - paddingTop - paddingBottom - arrowHeight)/2; //转换坐标原点的公式： x = x0+x; y = y0 - y; x = x + x0; y = y0 - y;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"art-template模板引擎","slug":"art-template的模板引擎","date":"2017-01-06T00:46:07.000Z","updated":"2019-04-26T06:05:03.000Z","comments":true,"path":"2017/01/06/art-template的模板引擎/","link":"","permalink":"http://yoursite.com/2017/01/06/art-template的模板引擎/","excerpt":"","text":"jQuery遍历对象$.each(data,function(i,e){e.attr})； attr就是对象的属性。 例如：$.each(data,function(i,e){ var date = new Date(Number(e.time+&apos;000&apos;)).toLocaleString(); infomation += &apos;&lt;ul&gt;&lt;li&gt;&apos;+ e.desc +&apos;&lt;/li&gt;&lt;li&gt;&apos;+ date +&apos;&lt;/li&gt;&lt;/ul&gt;&apos;; }) artTemplate方法一&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;basic-demo&lt;/title&gt; &lt;script src=&quot;../dist/template.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt; {{if isAdmin}} &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;ul&gt; {{each list as value i}} &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt; {{/each}} &lt;/ul&gt; {{/if}} &lt;/script&gt; &lt;script&gt; var data = { title: &apos;基本例子&apos;, isAdmin: true, list: [&apos;文艺&apos;, &apos;博客&apos;, &apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;] }; var html = template(&apos;test&apos;, data); document.getElementById(&apos;content&apos;).innerHTML = html; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; artTemplate方法二&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;compile-demo&lt;/title&gt; &lt;script src=&quot;../dist/template.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;在javascript中存放模板&lt;/h1&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script&gt; var source = &apos;&lt;ul&gt;&apos; + &apos;{{each list as value i}}&apos; + &apos;&lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;&apos; + &apos;{{/each}}&apos; + &apos;&lt;/ul&gt;&apos;; var render = template.compile(source); var data = { list: [&apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;] }; var html = render(data); document.getElementById(&apos;content&apos;).innerHTML = html; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; artTemplate方法三-嵌入子模板&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;include-demo&lt;/title&gt; &lt;script src=&quot;../dist/template.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; {{include 'list'}} &lt;/script&gt; &lt;script id=&quot;list&quot; type=&quot;text/html&quot;&gt; &lt;ul&gt; {{each list as value i}} &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt; {{/each}} &lt;/ul&gt; &lt;/script&gt; &lt;script&gt; var data = { title: &apos;嵌入子模板&apos;, list: [&apos;文艺&apos;, &apos;博客&apos;, &apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;] }; var html = template(&apos;test&apos;, data); document.getElementById(&apos;content&apos;).innerHTML = html; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意点{{each list as value i}} list可以为对象或者是数组，value为值，i为索引。 把获取到的时间转换为现在的时间var data = new Date(Number(e.time+&quot;000&quot;)).toLocaleString(); 因为从后台传回来的是json格式的字符串，并且new Date().toLocaleString();里面必须为数字。所以用Number强制转换为数字。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"模板引擎","slug":"模板引擎","permalink":"http://yoursite.com/tags/模板引擎/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javascript 面向对象：7","slug":"面向对象/面向对象第七天","date":"2016-12-26T01:00:48.000Z","updated":"2019-04-26T06:39:07.000Z","comments":true,"path":"2016/12/26/面向对象/面向对象第七天/","link":"","permalink":"http://yoursite.com/2016/12/26/面向对象/面向对象第七天/","excerpt":"","text":"正则表达式 regular expression 一个有规则的表达式 简单的说 他就是一个用于 查找的通配符 book bok bouk … b*k 或 b?k 将以 b 开头, 以 k 结尾的单词 全部列出来 正则表达式就是 一个用于查找的 含有 匹配字符串 或 匹配元字符的 字符串 &quot;123&quot; &quot;abc&quot; &quot;\\\\d&quot; 一个数字( 0 ~ 9 ) 正则表达式对象 js 正则表达式对象 就是 由 正则表达式创建的对象, 该对象可以进行 匹配, 提取 和 替换. 创建正则表达式对象 1) 构造函数 var regex = new RegExp( 正则表达式字符串[, 匹配模式] ); 2) 字面量 var regex = /正则表达式/; 使用正则表达式进行匹配 语法: 正则对象.test( 字符串 ) -&gt; bool 如果参数字符串中含有 复合 正则匹配的 子字符串, 就返回 true, 否则返回 false 例如: 查询一段文字中是否包含 itcast 基本元字符 1&gt; . 表示任一个非换行的字符 案例: foot _ 是 food, foot 写成 foo. 2&gt; () 表示分组和提高优先级 3&gt; [] 表示一个字符, 出现在 [] 中的字符 用法: [abc] 出现 [] 中的任意一个字符 匹配 a, 或 b, 或 c foo[dt] 4&gt; | 或 用法: 正则表达式|正则表达式 foot 或 food foot|food foo(t|d) 扩展: . 任意的一个字符. 没有任何限制 [] 是出现在[]中的一个字符. 认为 . 的限制级版本 [abc]: a 或者 b 或者 c | 可以认为是 允许使用多个字符的 匹配 a|b|c aa|bb|cc 转义字符: \\ 表示点: \\. 表示[]: \\[ \\] 表示(): \\( \\) 表示\\ : \\\\ 限定元字符 1&gt; * 紧跟前面的一个字符或一组字符出现 0 次到多次 表示: 123333333 后面很多 3 正则: 1233* 123 0 次 1233 1 次 12333 2 次 ... 1233333333333333333 1(23)* 表示: 1 0 次 123 1 次 12323 2 次 1232323 3 次 2&gt; + 紧跟在前面的字符出现 1 次到多次 字符串: 123333333 正则: 123+ 123 1233 12333 3&gt; ? 紧跟在前面的字符出现 0 次或 1 次 在一段字符串中检查是否含有 http 协议的字符串或 https 协议的字符串 http://.+|https://.+ https?://.+ 4 {数字} 紧跟在前面的字符出现指定次数 a{3} aaa 5 {数字,} 紧跟在前面的字符至少出现指定次数 a{3,} aaa, aaaaaaaaa, aaaaaaaaaaaaaa, ... 6 {数字, 数字} 紧跟在前面的字符出现的次数范围 a{1, 3} a, aa, aaa 首尾正则表达式 ^ 表示必须以 xxx 开头 ^a 必须以 a 开头的字符串 a 表示一个字符串中只要含有 a 就可以匹配 ^a^a 非法的写法, ^ 如果是表示开头必须写在开头, 而且只能写一个 $ 表示 必须以 xxx 结尾 a$ 必须以 a 结尾 分析 ^a+$ 案例 1&gt; 写一个正则表达式匹配 身份证号码 身份证是 18 位数字 省 市 区 出生年月 随机编码X 1) 首先是要做匹配, 就一定要使用 ^ $ 2) 是 18 位数字( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ). 可以使用 [0123456789] 还可以使用 0|1|2|3|4|5|6|7|8|9 3) 要求是 18 位. 限定 18 位, 即 {18} 组合: ^[0123456789]{18}$ 如果最后一位是x 前面 17 位数字: ^[0123456789]{17}$ 后面要么是数字: [0123456789] 要么是 x: x 写法: [0123456789x] [0123456789]|x 0|1|2|3|4|5|6|7|8|9|x ^[0123456789]{17}[0123456789x]$ 2&gt; 匹配邮箱 12345678901@qq.com abcdefg@126.com abcdefg@163.com abc@yahoo.com.cn .cc .org .edu .中文 ... 名字 @ 主机名 1) 是要验证邮箱, 那么就需要使用 ^ $ 2) 名字: 数字与字母 [0123456789] [abcdefghi...] [ABCDEFG...] [] 里面的字符如果是编码序号连续的可以使用连字符连接 数字: [0-9] [9-0] 错误的, 编码逆序 字母: [a-z] [A-Z] 整合: [0-9a-zA-Z] 名字的变式方法: [0-9a-zA-Z]+ 3) 主机名 主机名也是一串字符串或数字 但是它多了一个 .com .cn 3.1) 只有名字 [0-9a-zA-Z]+ 3.2) 只含有一个 .什么 开始 \\. 中间 [0-9a-zA-Z]+ 只含有一个名字: \\.[0-9a-zA-Z]+ 3.3) 含有多个名字 .com.con.cc.c1.c2.c3 即 .什么 出现一次到多次 (\\.[0-9a-zA-Z]+)+ 最后主机名可以写成 [0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+ 最后整合一下 ^[0-9a-zA-Z]+@[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)+$ 匹配一个数字 1&gt; 匹配一个数字 [0-9]+ 1) 由于是匹配, 包含 ^ $ 2) 首先第一个字符不允许是 0, 所以第一个可以写成 [1-9] 3) 后面的数字就是 [0-9] 4) 要求后面的数字出现 0 次到多次, 以匹配任意的 非 0 数字: [1-9][0-9]* 5) 由于还需要考虑 0, 因此写成 [1-9][0-9]*|0 6) 考虑 | 优先级最低: ^([1-9][0-9]*|0)$ ^(-?[1-9][0-9]*|0)$ 2&gt; 匹配一个指定范围的数字 匹配 0 ~ 255 为例 [0-255] 0, 1, 2, 5 错误的 如果要匹配指定范围的数字, 那么需要将字符串结构进行分类 1) 0 要匹配的, 所以在正则表达式中有 0 这一项 2) 任意的 2 位数, 即 [1-9][0-9] 3) 任意的 1 位数, 即 [0-9], 可以将 第 1) 结论合并 4) 考虑 3 位数的时候, 只允许出现 1xx 的任意数, 而 2xx 的有限制 因此在分组, 考虑 1xx 的任意数, 可以写成: 1[0-9][0-9] 5) 考虑 2xx 的数字, 在 200 到 250 之间允许任意取. 所以 写成: 2[0-4][0-9] 6) 考虑 250 到 255, 写成 25[0-5] 综合一起: ^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$ 匹配赢 IPv4 127.0.0.1 192.168.1.1 ^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))$ 3&gt; 匹配小数 要求, 小数不允许以 0 结尾 3.1415 [0-9]*[1-9] ^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9])?)$ (aaa)? 这个内容出现或不出现 (aaa|) 也是表达aaa可出现可不出现 ^((-?[1-9][0-9]*|0)(\\.[0-9]*[1-9]|))$ jq 中有一属性过滤选择器 [value=name] [value] [value !=name] ... 了解 \\[[a-zA-Z]((!|\\||~|^|$|)=...|)\\] 简写元字符 \\s 空白字符, 包括空格, tab, 回车换行等 \\S 非空白字符 js 中常常使用 [\\s\\S] 表示任意字符 \\w 表示字符, 包含字母, 数字, 下划线. \\W 非字符 \\d 数字 \\D 非数字 提取使用正则表达式可以进行匹配, 使用 exec 可以将匹配到的数据提取出来 语法: 正则表达式对象.exec( 字符串 ) -&gt; 封装成数组 案例： 在 ‘abc123def456ghij789klum’ 提取数字 循环提取在一个字符串中将所有复合的要求的字符串提取出来1&gt; 正则表达式需要使用全局模式 var r = new RegExp( &apos;正则&apos;, &apos;g&apos; ); var r = /正则/g; 2&gt; 调用 exec 首先获得第一个匹配项 再调用一次该方法, 就可以获得 第二个匹配项 一直调用下去, 就可以得到所有的匹配项 直到最后全部匹配完, 如果还用该方法, 则返回 null 案例： 在 ‘abc123def456ghij789klum’ 提取数字 var r = /\\d+/g; r.exec( str ) =&gt; 123 r.exec( str ) =&gt; 456 r.exec( str ) =&gt; 789 r.exec( str ) =&gt; null while ( res = r.exec( str ) ) { // 操作 res, 处理捕获的结果 } 将匹配到的结果进行解析假如有一个字符串: itcast@itcast.cn匹配提取邮箱, 同时将邮箱地址部分的名字和主机名都提取出来 案例:var str = ‘我有一个邮箱, 是 itcast@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com’要求将里面的邮箱全部提取出来, 然后将名字还有主机名也取出来 // 循环提取的正则表达式 var r = /[a-zA-Z\\d]+@[a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)+/g; // 如果需要将匹配到的结果再次分解, 可以使用分组的形式, 在正则中分组即可 var r = /([a-zA-Z\\d]+)@([a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)+)/g; // 注意, 正则表达式中, 分组是有编号的. 从左往右数 &apos;(&apos;. 从 1 开始依次编号 // 匹配提取的结果中, 对应的编号就可以获得分解的数据 匹配但是不去捕获的元字符(?:其他正则表达式内容) 要截取一个字符串中的一个 html 标签var str = ‘1234567890’; 1&gt; 要截取 html 标签, 标签使用 &lt;&gt;. 因此正则表达式写成 &lt;\\w+&gt;2&gt; 与之匹配的标签名是什么? 如果在一个正则表达式中使用组匹配到某一个数据, 允许在该正则表达式中使用 &apos;\\数字&apos; 的方式引用该组 &lt;(\\w+)&gt;.*&lt;\\/\\1&gt; 贪婪模式凡是在正则表达式中, 涉及到次数限定的, 一般默认都是尽可能的多匹配. 取消贪婪模式. 在次数限定符后面加上 ? 注意: 贪婪模式性能会略高于非贪婪模式, 所以开发的时候. 一般不考虑贪婪的问题 只有代码匹配结果出现问题了, 一般一次多匹配了, 才会取消贪婪 多个贪婪在一起的时候的强度 \\d+\\d+\\d+ 1234567 如果取消贪婪模式 \\d+?\\d+\\d+ 否定元字符语法: [^字符] 不为这些字符的字符 [^abc] 不是 a 也不是 b 也不是 c 的字符 字符串的替换语法: 字符串.replace( 查找字符串, 替换字符串 ) -&gt; 字符串 1&gt; 字符串替换方法 字符串1.replace( 字符串2, 字符串3 ) 在 字符串1 中找到 字符串2, 将其替换成 字符串3, 返回替换后的字符串 特点: 只替换第一个找到的字符串 &quot;aaa&quot;.replace( &apos;a&apos;, &apos;A&apos; ) -&gt; &apos;Aaa&apos; 2&gt; 正则替换 字符串.replace( 正则表达式, 字符串 ) -&gt; 字符串 1. 简单替换 &apos;aaaaa-------bbbbbb------ccccc&apos;.replace( /-+/, &apos;-&apos; ) &apos;aaaaa-------bbbbbb------ccccc&apos;.replace( /-+/g, &apos;-&apos; ) 2. 分组替换 可以在替换字符串中, 使用 $数字 来引用替换的数据 &apos;abc123&apos;.replace( /(\\d+)/, &apos;d$1&apos; ) -&gt; &apos;abcd123&apos; &apos;1991-1-1&apos; 中国: 1991年1月1日 欧洲: 1/1/1991 ... : 1991 1 1 &apos;1991-1-19&apos;.replace( /(\\d+)-(\\d+)-(\\d+)/, &apos;$1年$2月$3日&apos; ) 3&gt; 函数参数用法(了解) 语法: 字符串.replace( 正则表达式, fn ) &apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijk@itcast.cn&apos; .replace( /\\w+@\\w+(\\.\\w+)+/g, &apos;*&apos; ); &apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: def@itcast.cn&apos; .replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) { return &apos;*&apos;; } ); // 要求 只显示 第一个字符, 其余的都是用 * 表示 &apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijklim@itcast.cn&apos; .replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) { // 将用户名 变成 a***** 的形式 var first = g1.charAt( 0 ); var start = []; for ( var i = 0; i &lt; g1.length - 1; i++ ) { start.push( &apos;*&apos; ); } return first + start.join(&apos;&apos;) + &apos;@&apos; + g2; } );","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javaScript 字符串操作","slug":"字符串方法","date":"2016-12-26T00:59:17.000Z","updated":"2019-04-26T06:04:40.000Z","comments":true,"path":"2016/12/26/字符串方法/","link":"","permalink":"http://yoursite.com/2016/12/26/字符串方法/","excerpt":"","text":"javaScript 字符串操作 获取字符串长度Length属性string.length 连接字符串：concats1.concat(1,2,3); 获取索引值：indexOf()string.indexof(“v”)string.indexof(“v”,fromIndex)如果没有就返回-1表示从索引位置fromIndex开始查找，如果fromIndex省略，则表示默认从起始索引0开始查找若fromIndex为负，则从索引0开始查找. 根据索引值获取单个字符：charAt() substr(fromIndex,length)获取部分字符串从起始索引fromIndex开始截取长度length的字符串 substring(startIndex,endIndex)获取部分字符串截取 起始索引startIndex 到 结束索引endIndex的子字符串，结果包含startIndex处的字符，不包含endIndex处的字符。 slice(startIndex,endIndex)获取部分字符串截取 起始索引startIndex 到 结束索引endIndex的子字符串，结果包含startIndex处的字符，不包含endIndex处的字符。 split()分割按给定字符串分割，返回分割后的多个字符串组成的字符串数组。 Join()合并使用您选择的分隔符将一个数组合并为一个字符串 toLowerCase()转小写toUpperCase()转大写字符串大小写转换使用您选择的分隔符将一个数组合并为一个字符串","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javascript 面向对象：6","slug":"面向对象/面向对象第六天","date":"2016-12-24T12:16:07.000Z","updated":"2019-04-26T06:38:58.000Z","comments":true,"path":"2016/12/24/面向对象/面向对象第六天/","link":"","permalink":"http://yoursite.com/2016/12/24/面向对象/面向对象第六天/","excerpt":"","text":"1 forEach var arr = [ ‘hello’, ‘ js’, { }, function () {} ]; // 遍历 数组 arr.forEach( function ( v, i ) { console.log( i + ‘=====’ + v ); }); 2 map 映射 语法: 数组.map( fn ) 返回一个数组, 数组的每一个元素就是 map 函数中的 fn 的返回值 var arr = [ 1, 2, 3, 4 ]; 数学中: x -&gt; x * x var a = arr.map(function ( v, i ) { return v * v; }); 3 filter 就是筛选 语法: 数组.filter( function ( v, i ) { return true/false }) var arr = [ 1, 2, 3, 4, 5, 6 ]; var a = arr.filter( function ( v ) { return v % 2 === 1; }); 4 some 判断数组中至少有一个数据复合要求 就返回 true, 否则返回 false var arr = [ &apos;123&apos;, {}, function () {}, &apos;123&apos; ]; 判断数组中至少有一个数数字 var isTrue = arr.some( function ( v ) { return typeof v === &apos;number&apos;; } ); 5 every 必须满足所有元素都复合要求才会返回 true var arr = [ 1, 2, 3, 4, 5, &apos;6&apos; ]; var isTrue = arr.every( function ( v ) { return typeof v === &apos;number&apos;; } ); 6 indexOf 在数组中查找元素, 如果含有该元素, 返回元素的需要( 索引 ), 否则返回 -1 var arr = [ 1, 2, 3, 4, 5 ]; var res = arr.indexOf( 4 ); console.log( res ); var arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ]; var res = arr.indexOf( 4, 4 ); console.log( res ); 7 lastIndexOf 从右往左找 var arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ]; var res = arr.lastIndexOf( 4 ); console.log( res ); 函数的四种调用模式 -&gt; 函数有下列调用模式 1&gt; 函数模式 2&gt; 方法模式 3&gt; 构造器模式 4&gt; 上下文模式 函数调用 模式 -&gt; 函数的定义方式 1&gt; 声明式 2&gt; 表达式式 3&gt; Function -&gt; 单独独立调用的就是函数 函数名( 参数 ) -&gt; this 表示全局对象 -&gt; 任何自调用函数都是函数模式 方法调用 模式 method -&gt; 区分 方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用. 对象.方法( 参数 ) -&gt; this 表示引导方法的对象 面试题 var length = 10; function fn() { console.log( this.length ); } var obj = { length: 5, method: function ( fn ) { fn(); arguments[ 0 ](); } }; obj.method( fn, 1 ); 构造器模式(构造函数模式, 构造方法模式) constructor -&gt; 区分 使用 new 关键字引导 -&gt; 执行步骤 var p = new Person(); new 是一个运算符, 专门用来申请创建对象, 创建出来的对象传递给构造函数的 this 利用构造函数对其初始化 function Person () { this.name = &apos;jim&apos;, this.age = 19; this.gender = &apos;male&apos;; } -&gt; 返回值 如果不写 return 语句, 那么 构造函数 默认返回 this 如果在构造函数中写上 return 语句, 并紧跟基本类型( return num, return 1223 ). 则忽略返回类型. 如果在构造函数中写上 return 语句, 并且紧跟引用类型, 那么构造函数返回该引用类型数据, 而忽略 this -&gt; 如果调用构造函数的时候, 构造函数没有参数, 圆括号是可以省略的 关于构造函数结核性的一个小结 1&gt; 如果构造函数没有参数, 可以省略 圆括号 var p = new Person; 2&gt; 如果希望创建对象并直接调用其方法 ( new Person () ).sayHello() -&gt; 可以省略调整结核性的圆括号 new Person().sayHello() -&gt; 如果想要省略构造函数的圆括号, 就必须添加结核性的圆括号 (new Person).sayHello() 上下文调用模式 就是 环境调用模式 =&gt; 在不同环境下的不同调用模式 简单说就是统一一种格式, 可以实现 函数模式与方法模式 -&gt; 语法(区分) 1&gt; call 形式 函数名.call( ... ) 2&gt; apply 形式 函数名.apply( ... ) 这两种形式功能完全一样, 唯一不同的是参数的形式. 首先学习 apply, 再来看 call 形式 -&gt; 用法 存在上下文调用的目的就是为了实现借用方法 function foo () { console.log( this ); } var o = { name: &apos;jim&apos; }; foo(); o.func = foo; o.func(); // 如果需要让函数以函数的形式调用, 可以使用 foo.apply( null ) 或 foo.apply() // 如果希望他是方法调用模式, 注意需要提供一个宿主对象 foo.apply( o ) -&gt; 带有参数的函数如何实现上下文调用 function foo ( num1, num2 ) { console.log( this ); return num1 + num2; } // 函数调用模式 var res1 = foo( 123, 567 ); // 方法调用 var o = { name: &apos;jim&apos; }; o.func = foo; var res2 = o.func( 123, 567 ); 使用 apply 进行调用, 如果函数是带有参数的. apply 的第一个参数要么是 null 要么是对象 如果是 null 就是函数调用, 如果是 对象就是 方法对象, 该对象就是宿主对象, 后面紧跟一个 数组参数, 将函数的参数依次放在数组中. 例如: 函数模式 foo( 123, 567 ); apply foo.apply( null, [ 123, 567 ] ) 如果有一个函数调用: func( &apos;张三&apos;, 19, &apos;男&apos; ), 将其修改成 apply 模式 func.apply( null, [ &apos;张三&apos;, 19, &apos;男&apos;] ) 方法模式: o.func( 123, 567 ) apply foo.apply( o, [ 123, 567 ] ) call 调用 在使用 apply 调用的时候, 函数参数, 必须以数组的形式存在. 但是有些时候数组封装比较复杂 所以引入 call 调用, call 调用与 apply 完全相同, 唯一不同是是参数不需要使用数组 foo( 123, 567 ); foo.apply( null, [ 123, 567 ] ); foo.call( null, 123, 567 ); 借用构造方法实现继承 function Person ( name, age, gender ) { this.name = name; this.age = age; this.gender = gender; } function Student ( name, age, gender, course ) { Person.call( this, name, age, gender ); this.course = course; } var p = new Student ( ‘jim’, 19, ‘male’, ‘前端’ ); 函数的 bind 方法bind 就是 绑定 Object.prototype 的成员1) constructor2) hasOwnProperty 判断该属性是否为自己提供3) propertyIsEnumerable 判断属性是否可以枚举4) isPrototypeOf 判断是否为原型对象5) toString, toLocaleString, valueOf 包装对象字符串 string 是基本类型, 理论上讲不应该包含方法charAt, substr, slice, … 在 js 中为了更好的使用数据, 为三个基本类型提供了对应的对象类型 NumberStringBoolean 在 开发中常常会使用基本数据类型, 但是基本数据类型没有方法, 因此 js 引擎会在需要的时候自动的将基本类型转换成对象类型. “abc”.charAt( 1 ) “abc” -&gt; new String( “abc” )s.charAt( 1 ) 返回结果s 就被销毁 当 基本类型.方法 的时候. 解释器首先将基本类型转换成对应的对象类型, 然后调用方法.方法执行结束后, 这个对象就被立刻回收 在 apply 和 call 调用的时候, 也会有转换发生. 上下文调用的第一个参数必须是对象. 如果传递的是数字就会自动转换成对应的包装类型 getter 与 setter 的语法糖 语法糖: 为了方便开发而给出的语法结构 var o = (function () { var num = 123; return { get_num: function () { return num; }, set_num: function ( v ) { num = v; } }; })(); // 获得数据o.get_num(); =&gt; o.num 形式 // 设置o.set_num( 456 ); =&gt; o.num = 456 形式 var o = (function () { var num = 123; return { // get 名字 () { 逻辑体 } get num () { return num; } // set 名字 ( v ) { 逻辑体 } set num ( v ) { num = v; } }; })(); ES5 中引入的部分数组方法1&gt; forEach2&gt; map3&gt; filter4&gt; some5&gt; every6&gt; indexOf7&gt; lastIndexOf","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javascript 面向对象：5","slug":"面向对象/面向对象第五天","date":"2016-12-23T13:23:31.000Z","updated":"2019-04-26T06:38:53.000Z","comments":true,"path":"2016/12/23/面向对象/面向对象第五天/","link":"","permalink":"http://yoursite.com/2016/12/23/面向对象/面向对象第五天/","excerpt":"","text":"复习 var num = 123; function num () { console.log( &quot;Hello&quot; ); } console.log( num ); 递归的概念 -&gt; 递归就是直接或间接的调用自己 -&gt; 直接调用 function func() { // ... console.log( 123 ); func(); // 递归了 // ... } -&gt; 间接调用 function func1 () { func2(); } function func2 () { func1(); } -&gt; 就以直接调用为例. 分析特点. 将函数调用想象成做一件事儿. 函数调用, 就是在做事儿. 递归, 就是函数在调用的时候, 转而去调用自己. 就是要完成 xxx1, 就完成 xxx2 完成 xxx2, 就完成 xxx3 完成 xxx3, 就完成 xxx4 ... ... 其实就是将要做某件事儿, 转换成已经解决的问题. 然后根据逻辑关系找到临界条件( 已经解决的问题 ) -&gt; 求 n 的阶乘 n 的阶乘 记为 n!, 表示 从 1 一直累乘到 n. 比如 3! == 1 * 2 * 3, 5! == 1 * 2 * 3 * 4 * 5 利用递归实现深拷贝 -&gt; 深拷贝 -&gt; 拷贝: 复制 var o = { name: &apos;itcast&apos; }; var o1 = o; // 拷贝 var o2 = {}; o2.name = o.name; clone: for-in 遍历对象, 然后将一个对象成员加到 {} 上, 返回 -&gt; 代码 function clone ( obj ) { // 将 目标对象 拷贝一份 var src = {}, k; for ( k in obj ) { src[ k ] = obj[ k ]; } return src; } document.getElementsByClassName 使用递归实现该方法 getByName( ‘*’ ) 父子节点的关系去完成 body下找所有的子元素, 凡是有 className 等于 给定值 的就取出来 但是 标签还有子标签, 利用递归处理子标签 闭包应用 -&gt; 闭包的概念 -&gt; 闭包代码的基本结构 function foo () { var num = 123; return function () { return num; } } -&gt; 如果函数中定义了两个变量, 外界如何访问 function foo () { var num1 = 123, num2 = 456; // 怎样让外界既可以访问 num1 又可以访问 num2 return [ function () { return num1; }, function () { return num2; } ]; } -&gt; 闭包实现各种特性, 其根本的核心内容只有两个 1&gt; 带有私有数据的函数 function foo () { var num = 123; return function () { // 可以访问 num } } var func = foo(); // 称 func 是一个 带有私有数据的 函数 // 称 func 带有缓存 2&gt; 带有私有数据的 对象 闭包的应用__沙箱模式 沙箱就是一个隔离的执行环境 在 js 中什么情况需要使用沙箱 function Person () { … } var p = Person. … Person.prototype = …. … 定义变量越多, 会怎样? 出现冲突的可能性越大. (function () {} )(); var f = function () {}; f(); 同理, 在 代码中 有时为了使得代码更加简洁, 会引入很多变量 (function () { // 沙箱模式 // 所有的代码写在这里 })(); 闭包的应用__简化递归函数的性能问题 闭包的应用__模拟 onload 事件的追加与移除 o.addEvent( function … ) o.removeEvent( fn ) 系统 调用 load() 按照一定顺序执行 所以, 我们需要有一个对象, 有两个方法, 用来追加移除事件, 需要一个私有数组存储函数 var itcastload = (function () { // 私有数据 return { }; })(); 利用闭包模拟一个缓存结构 cache 对象, 可以使用 cache[ key ] = value 存储数据, cache[ key ] 获得数据 当 cahche 里面的数据达到 1024 条, 将最早放进去的数据移除 cache = {} 可以存取数据, 但是不能限定数据的长度 如果需要限定数据, 就是在加入数据的时候 判读, 是否已超过尺寸. 如果是, 则移除, 如果不是, 则什么也不做 将 cache 做成函数, 添加数据使用 cache( key, value ) 而且函数本身也是对象 function cache ( key, value ) { // 可以在这里加上限定长度的代码 cache[ key ] = value; } 由于需要记录键的数量. 并且需要记录添加数据的先后顺序. 所有首先考虑有序的数组. 因此需要让 cache 函数带有缓存功能 var cache = (function () { var data = []; function cache ( key, value ) { // 做判断, 如果超出范围, 则, 将最开始加入的 移除 // 将数组 第 0 项元素移除的 splice, shift cache[ key ] = value; } return cache; })(); 10.函数是基本的对象类型，可以作为变量赋值，可以作为参数使用，也可以作为返回值使用。 闭包应用 带有事件（移除与追加）的对象 11.1定义一个自调用函数 (function(){})()把所有方法放在 data = [] 并在window.onload = function(){};加载完就执行。添加事件 return{addEvent:function(fn){ data.push(fn)},removeEvent:function(fn){ // 倒过来循环 for ( var i = data.length - 1; i &gt;= 0; i– ) { if ( data[ i ] === fn ) { data.splice( i, 1 ); } } } }这里注意在 1，删除的遍历时要倒着遍历 因为数组的长度在发生改变 2，在使用删除的时候需要把事件提出来 是一个变量储存 才可以实现删除","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javascript 面向对象：2","slug":"面向对象/面向对象第二天","date":"2016-12-22T02:50:00.000Z","updated":"2019-04-26T06:38:40.000Z","comments":true,"path":"2016/12/22/面向对象/面向对象第二天/","link":"","permalink":"http://yoursite.com/2016/12/22/面向对象/面向对象第二天/","excerpt":"","text":"为什么需要原型 构造器创建对象的时候, 实际上会有成员重复 如果使用 构造器 this.方法名 = function …. 方式创建对象. 那么每一个对象 对应的方法就会重复. 解决办法就是让这个方法( 函数 )共享 -&gt; 将函数写到外面, 那么 Person 在初始化对象的时候就不会再创建一个函数了. 只需要将 外面的函数引用 交给对象即可. 缺点: 一个对象可能有 n 多方法. 如果将所有的东西 都放到外面, 与其他库 冲突的几率就会变大. 所以不宜采取该方法. -&gt; 将所有的方法( 函数 )都绑定到一个对象中. -&gt; js 原生就支持解决该问题的办法 每一个函数都有 一个属性 prototype 该属性指向一对象. 每一个函数的该对象都是存在. (重点) 每一个由该函数作为构造器创建的对象, 都会默认连接到该对象上. 如果访问对象的方法, 而对象中没有定义, 就会在这个 构造函数.prototype 表示的对象中去找. -&gt; prototype 就是原型之意 针对构造函数而言, 原型就是 构造函数的 prototype 属性, 常常将其称为 原型属性.针对实例对象而言, 原型就是 实例对象的 原型对象. 例: function Person () {} // 有了构造函数, 和 原型 var p = new Person(); // 有了实例 一般如何使用原型对象 -&gt; 简单的说就是将共享的方法放到原型中, 而独有数据与行为放在当前对象里 -&gt; 例: Person( name, age, gender, sayHello, eat, run ) -&gt; 直接给原型对象添加成员 -&gt; 直接替换原型对象( 注意: 手动的添加 constructor 属性, 表示对应的构造函数 ) proto和 prototype 是否存在关系 早期浏览器是不支持 proto火狐率先使用该属性, 但是是非标准基本现在的新浏览器都支持该属性 -&gt; 访问 使用构造函数, 就使用 prototype 属性访问原型 使用实例对象, 就使用 非标准的 __proto__ 属性访问原型 继承 -&gt; 什么是继承 自己没有, 别人有, 拿过来自己用, 就好像自己的一样. -&gt; 原型与实例对象 在 js 中, 方法定义在原型对象中, 而属性定义在实例对象中 调用方法的时候, 实例对象本身是没有该成员的, 但是依旧可以调用 该方法, 好像这个方法就是该实例对象的一样. 因此, 我们称该实例对象 继承自 原型对象 -&gt; 任何一个实例, 都是继承自其原型对象的. 即原型式继承. 为什么需要继承 -&gt; 编程的发展 复用( 重复使用 ) div 标签对象 nodeName, nodeType, nodeName, ... appendChild, insertBefore, getElementsByTagName, ... a 标签对象 baseElement -&gt; js 运行效率 共享特性 复用 传统的编程语言的面向对象操作 -&gt; 对象: 是具有方法和属性的逻辑单元 在 js 函数是一个特殊的数据类型( 函数在 js 是一等公民 ) js 对象就是键值对, 值如果是数据, 那么键值就构成属性 如果值是函数, 那么就构成方法. -&gt; 创建方式 类 -&gt; 实例化 -&gt; 对象( 实例 ) class Person { public string name; public int age; public string gender; public void sayHello () { // ... } } // 类, 用来描述对象的结构, 它就是一个模板 Person p = new Person(); // 利用模板创建对象 // 访问属性 p.name // 调用方法 p.sayHello(); 传统的面向对象编程语言, 重点需要一个&quot;模板&quot;, 即 类( class ) -&gt; 传统的继承 传统的继承是模板的继承. class Student : Person { } Student s = new Student(); // 注意此时 s 就可以调用 sayHello 方法 // 可以使用 name, age, 和 gender 属性了 相关概念 类 class 模板 构造函数, 类名就是构造函数名 子类 subclass 派生的模板 原型设置为指定对象的构造函数 实例 instance 某个类的对象 … 实例成员(实例方法, 实例属性) 静态成员 静态方法 ... 直接绑定在函数上的方法 静态属性 ... 直接绑定在函数上的属性 // js 代码 function Person () { this.name = &apos;黄帝&apos;; this.age = 0; this.gender = &apos;男&apos;; } // 不叫子类, 只是一个 Student 类 function Student() { } // 继承派生 成为子类 Student.prototype = new Person(); // 即完成派生 var s = new Student(); s.name // OK 属性访问原则( 重点 ) 1) 对象在调用方法或访问属性的时候, 首先在当前对象中查询. 如果有该成员使用并停止查找. 2) 如果没有该成员就在其原型对象中查找. 如果有该成员即使用, 并停止查找. 3) 如果还没有就到 该对象的 原型对象 的 原型对象中查找. … 4) 最后会查到 Object.prototype 上. 如果还没有即 返回 undefined. 如果修改原型对象中的属性值会怎样给当前对象的原型提供的属性赋值, 实际上是给当前对象添加了该属性的新成员并不会修改运行对象中的成员. 混入( mix ) var o1 = { name: ‘张三’ }; var o2 = { age: 19 };o2.name = o1.name利用这个简单的赋值, 就可以将一个对象中的成员加到另一个对象中执行混入操作， 如果o2里面有name值，则将会被覆盖。混入使得 o2 具有了 age 和 o1 中的 name. 即将 o1 混入到 o2 中 混入也是一种继承的方式实例 var o = { extend:function(obj){ for (var i = 0; i < arguments.length; i++) { for(var k in arguments[i] ){ this[k]=arguments[i][k]; } } } }; o.extend({name:\"sy\"},{age:18},{sex:\"男\"}); console.log(o); 如何使用代码实现混入 // 考虑需要执行, 写函数即可// 由于将 一个 对象混入到 另一个对象. 所以有两个参数function mix ( obj, obj1 ) { // 如何获得 obj1 中的所有成员? for ( var k in obj1 ) { obj[ k ] = obj1[ k ]; } } 原型式继承-&gt; 写一个构造函数, 如果需要将其实例继承自某个特定的对象 o. 那么 只需要设置该构造函数的 prototype 属性为 o 即可 function Person {} var o = { ... } Person.prototype = o; // 继承 混合式继承-&gt; 混合就是将多个对象的各个功能混合到一起, 加到构造函数的原型对象上. 那么该构造函数创建的实例 就继承自多个对象了. 对象 -&gt; 父对象 -&gt; 父对象的父对象 -&gt; … -&gt; 原对象 -&gt; ….链式结构( 原型链 ) 由于链越深, 属性搜索越需要性能. 所以一般少用深层次的链式结构继承一般使用时, 链结构只有 3 级. 一般都是使用混入, 在原型上加成员 ES5 中 的 Object.create继承的最经典结构 function Animal() {} function Person() {} Person.prototype = new Animal(); 语法: 新对象 Object.create( 原对象 ); 例如 var o ={name:&quot;sy&quot;,age:20,gender:&quot;男&quot;} var obj = Object.create(o); 实现继承的快速方法 如果在低版本的浏览器中要使用该方法 ，先判断有没有，如果没有在加上。if(!Object.create){ Object.create = function(o) { function F(){} f.prototype = o; return new F(); };}这个写法已经过时了现在使用function createWithObject ( obj ) { if ( Object.create ) { return Object.create( obj ); } else { function F() {} F.prototype = obj; return new F(); } } 实际应用 var o ={name:\"sy\",age:20,gender:\"男\"}; var obj = createWithObject(o); console.log(obj); function createWithObject ( obj ) { if ( Object.create ) { return Object.create( obj ); } else { function F() {} F.prototype = obj; return new F(); } } // jQuery // Sizzle 引擎 select 方法 // 在这个方法, 首先判断系统是否具有 querySelectAll 方法. 如果有直接使用 // 如果没有 再自己实现","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javascript 面向对象：3","slug":"面向对象/面向对象第三天","date":"2016-12-21T00:30:10.000Z","updated":"2019-04-26T06:38:44.000Z","comments":true,"path":"2016/12/21/面向对象/面向对象第三天/","link":"","permalink":"http://yoursite.com/2016/12/21/面向对象/面向对象第三天/","excerpt":"","text":"复习 -&gt; 继承 原型式继承 function Person() {} Person.prototype = 父对象; var p = new Person(); p 继承自 父对象 混入 ( mix, extend ) function extend( o1, o2 ) { for ( var k in o2 ) { o1[ k ] = o2[ k ]; } } 注意命名规则: 1&gt; 一般 将一个对象混入另一个对象, 使用 mix 2&gt; 如果是当前对象的方法. 是将另一个对象混入当前对象一般使用 extend 对象的原型链 -&gt; 凡是对象都有原型 -&gt; 构造函数 Person 创建的对象 p 有原型 Person.prototype -&gt; Person.prototype 是对象. 它有原型吗? -&gt; 问题: 1) 原型是什么? 2) 原型既然是对象, 那么如何是个头? -&gt; 结论 1) Person.prototype 是 实例 p 的原型对象, 使用 __proto__ 可以访问对象的原型对象 2) Person.prototype 的 原型对象是 Person.prototype.__proto__ 3) Person.prototype.__proto__ 里的 constructor 是 Object. 所以 Person.prototype.__proto__ 就是 Object.prototype 4) Object.prototype.__proto__ 是 null. 因此表明 Object.prototype 就是顶级. -&gt; 链式 p --&gt; Person.prototype( p.__proto__ ) --&gt; Object.prototype --&gt; null -&gt; 系统内置的原型链 [] --&gt; Array.prototype --&gt; Object.prototype --&gt; null /./ --&gt; RegExp.prototype --&gt; Object.prototype --&gt; null ... ... 绘制数组的原型结构 var arr = []; // 等价 var arr = new Array(); arr –&gt; Array.prototype –&gt; Object.prototype –&gt; null 练习: 根据下面代码绘制对象的原型链结构 1) function Person( name, age, gender ) { this.name = name; this.age = age; this.gender = gender; } function Student () {} Student.prototype = new Person( &apos;张三&apos;, 19, &apos;男&apos; ); var stu = new Student(); 2) function Person() {} var p1 = new Person(); var p2 = new Person(); {} 对象的原型链结构 在 js 中 对象 一般都有字面量 123, &apos;123&apos; 数组: [] 正则表达式对象: /./ 函数: function () {} … 对象也有字面量: {} {} –&gt; Object.prototype –&gt; null 注意: {} 与 new Object() 含义相同 动态函数 Function -&gt; 动态函数就是在运行的过程中, 将一段字符串作为代码运行. 由于字符串可以随意的拼接. 因此得到动态的执行. -&gt; 定义动态函数, 并执行 -&gt; 使用 Function 构造函数, 创建函数. Function 是一个构造函数. new Function 得到 一个函数 -&gt; 语法 new Function( arg0, arg1, ..., argN, body ) Function 的所有的参数, 除了最后一个以外, 都是生成的函数的参数 最后一个参数是 函数体 函数的相关的一些参数 arguments 凡是函数调用, 都会默认含有一个 arguments 对象. 可以将其看做为 “数组”. 里面存储着调用时 传入的所有参数. 可以使用数组的索引访问这些参数. 例如: 写一个函数, 在参数中写任意个参数, 最后求其和 function sum () { // 所有的参数都会存储到 arguments 中 var sum = 0; for ( var i = 0; i &lt; arguments.length; i++ ) { sum += arguments[ i ]; } return sum; } 案例: extend( o ) =&gt; 将 o 混入到当前对象 this 中 extend( o1, o2 ) =&gt; 将 o2 混入到 o1 中 函数名.length, 即函数的 length 属性. 表示 定义函数时, 参数的个数 如果定义函数的时候, 定义了参数. 但是调用的时候又没有传递该参数. 那么该参数在函数内就是 undefined 函数.name 返回的是函数名 函数的引用 callee 与 caller js 中函数也是一个对象 -&gt; callee 在函数的内部, 它表示 当前函数 的引用 一般在函数内部, 实现函数递归的时候, 我们一般使用 callee 表示函数的引用 function fn() { arguments.callee(); // 使用 callee 来递归 } fn(); -&gt; caller 表示调用函数的函数 //caller 就是在被调用函数中, 获得调用函数的引用 function f2 () { console.log( f2.caller ); } function itcast() { f2(); } itcast(); eval 函数 eval 函数与 Function 功能类似. eval 可以直接将字符串作为代码来执行. 语法: eval( 语句字符串 ) 注意, 它好像与当前代码处于同一个作用域 eval 直接调用即执行。 Function 生成了一个函数function 需要调用才执行 使用 ajax 获得 json 格式的字符串后, 转换成对象var data = ‘[ { “name”: “张三”, “age”: 19, “gender”: “男”}, { “name”: “李四”, “age”: 18, “gender”: “女”} ]’; json 格式( 严格的国际通用数据表示协议, 结构 ) 在 js 中使用的 json 对象, 相对较松散 json 格式 有两种结构 1: {} 2: [] 注意: json 格式中, 键名也必须使用双引号括起来. 将字符串变成对象, 有三种做法 1. eval 做法 var o1 = eval( “(“ + data + “)” ); // 注意一个习惯. 就是数据两端一般加上圆括号为好 2. Function 做法 var o2 = (new Function( ‘return ‘ + data ))(); 3. 使用 ES5 中引入的标准处理 JSON 的语法 JSON.parse( ) 注意: 字符串必须是严格是 json 格式 var o3 = JSON.parse( data ); 在 js 中 函数 是 Function 的实例 function Person() {}var p = new Person();p 是 构造函数 Person 的实例 在 该角度去看, 函数就是对象, Function 就是构造函数 得到 构造-实例-原型 三角形 function Person() {} 为例 给定一个任意的对象, 将其原型链包括对象和函数的结构完整的分析处理 instanceof 运算符-&gt; a of b -&gt; b 的 a-&gt; instance of ?-&gt; 错觉: 判断某一个对象是否为某一个构造函数所创建出来的 通过原型链的学习, 可以重新定义 js 的继承 js 的继承: 就是利用对象的动态特性添加成员, 或直接替换对象的方式修改原型链 结构. 使得当前对象的原型链上的对象具有某些成员. 那么我的当前对象 就可以使用这些成员了. p -&gt; Person.prototype -&gt; Object.prototype -&gt; nullp -&gt; Person.prototype -&gt; {} -&gt; Object.prototype -&gt; null 过多的依赖原型链继承, 会损耗 性能如果必须使用原型链继承, 最好提供一些快速访问的方法","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javascript 面向对象：4","slug":"面向对象/面向对象第四天","date":"2016-12-20T09:55:48.000Z","updated":"2019-04-26T06:38:49.000Z","comments":true,"path":"2016/12/20/面向对象/面向对象第四天/","link":"","permalink":"http://yoursite.com/2016/12/20/面向对象/面向对象第四天/","excerpt":"","text":"复习 加入我希望所有的函数都具有 inherit 功能 function Person() {} var Student = Person.inherit( 成员 ); // 生成函数 Student, 但是 Student 里面的成员( this.XXX ) // 由参数来提供, 而 Student 的对象, 继承自 Person 的对象 如果希望所有的函数都有 inherit 方法, 那么可以给 Function.prototype 添加该方法 代码的预解析 -&gt; 预解析 预 解析 提前的翻译解释, 在运行代码之前的一个解释. -&gt; 为什么需要它 -&gt; 编译型语言: C, C++, C#, Java 就是需要一个 &quot;翻译&quot; 程序, 将源代码翻译成计算机可以读懂的二进制数据( 指令 ). 然后存储成可执行文件. 提前翻译好, 运行时直接执行得结果 -&gt; 解释型( 脚本型 ): JavaScript, SQL, ... 代码在执行的时候, 有一个翻译程序, 读一句代码执行一句代码. 再读一句代码, 再执行一句代码. 一句一句的翻译执行. 每次运行都需要翻译一次. -&gt; 代码在执行之前, 需要快速的 &quot;预览&quot; 一遍. 那么可以尽可能提高执行效率. 在 js 中预解析的特点 -&gt; 代码是如何执行的: 读取 js 文本, 预解析, 一句一句地执行 -&gt; js 在预解析的过程中完成了声明部分的标记与变量作用域的设定 什么是 js 中的声明 -&gt; 简单的说就是让 js 执行引擎知道有什么东西( 标识符 ) console.log( num ); // error: num is not defined num(); // error: is not function 即代码在执行之前的预解析, 首先让 js 的执行引擎知道在当前运行环境中 有什么东西( 名字, 标识符 )是可以被使用的. 它是变量, 还是函数等? -&gt; 在 js 中有哪些声明: 1) 标识符的声明( 变量的声明 ) 2) 函数的声明 -&gt; 变量的声明: 语法: var 变量名; 目的: 告诉解释器, 有一个名字是一个变量, 在当前环境中可以被使用. 语句: 就是可以执行的东西. var a = 123; 是一个语句 在使用 var 声明变量, 同时完成赋值的时候. 实际上, 预解析将其做了一定处理: -&gt; 凡是读取到 var 的时候, 就检查 var 紧跟的名字是否已经标记了 -&gt; 如果没有标记, 就表明这个名字是一个标识符, 需要被标记 -&gt; 如果已经被标记了, 那么 这个 var 被忽略 结论: var a; var a = 10; 等价 var a; a = 10; var a = 123; var a = 456; var a = 789; 等价于 var a = 123; a = 456; a = 789; 如果在代码中有多个 var 后面紧跟的名字是一样的. 那么只有第一个 var 起作用. 后面的所有 var 都会被自动的忽略. -&gt; 变量名提升 -&gt; 函数的声明 -&gt; 函数的各种定义形式 -&gt; 声明式: function func () { console.log( &apos;使用声明式定义&apos; ); } -&gt; 表达式式( 匿名函数, 字面量函数, lambda 函数 ): var func = function () { console.log( &apos;使用表达式式定义&apos; ); }; -&gt; ... -&gt; 特点: 1&gt; 函数的声明是独立于语句. 不需要加分号结束. 也不能嵌入到代码表达式中. 2&gt; 表达式式, 本质上是使用函数表达式( 字面量 )给变量赋值. 因此它是语句. -&gt; 表达式: -&gt; 将运算符与操作数连接起来的式子. -&gt; 就是一个有结果的代码单元( 不包括语句 ) var a; // 声明, 不是语句, 也没有结果 123 // 字面量, 有值, 是表达式. 是常量表达式 a = 123 // 赋值, 有值, 就是被赋值的那个值. 是赋值表达式. function () {} 如果将变量的声明与函数的声明放在一起有些需要注意的情况 1) 函数的声明实际上包含两部分 1&gt; 告诉解释器 xxx 名字已经可以使用( 函数名, 标识符 ) 2&gt; 告诉解释, 这个名字代表着一个函数( 变量里存储着函数的引用 ) 2) 当函数声明与变量声明冲突的时候. 只看谁先有数据. 一个在新版本的浏览器中的特性 if ( true ) { function foo() { console.log( true ); } } else { function foo() { console.log( false ); } } foo(); 词法作用域 -&gt; 作用域: 就是变量可以使用到不能使用的范围 -&gt; 块级作用域: -&gt; 块: 代码块, 即 { } -&gt; 变量的使用从定义开始, 到其所在的块级作用域结束 // js 伪代码 { console.log( num ); // error: num 未定义 var num = 123; { console.log( num ); // =&gt; 123 } console.log( num ); // =&gt; 123 } console.log( num ); // error: num 未定义 -&gt; 代表语言: C, C++, C#, Java, ... -&gt; js 是词法作用域 -&gt; 词法: 就是定义, 书写代码的规则. -&gt; 所以 所谓的 词法作用域, 就是 在书写代码的时候, 根据书写代码的结构 就可以确定数据的访问范围的作用域. -&gt; js 不受 块的影响, 即使在块中定义声明变量, 在块的外面依旧可以使用 console.log( num ); // =&gt; undefined { var num = 123; } console.log( num ); // =&gt; 123 -&gt; 所谓的 js 的词法作用域, 就是根据预解析规则定义变量的使用范围, 全部代码中 只有函数可以限定范围. 其他均不能限定访问范围. 在内部是一个独立的作用范围结构. -&gt; 结论: 词法作用域就是描述变量的访问范围: 1&gt; 在代码中只有函数可以限定作用范围. 允许函数访问外部的变量. 反之不允许. 2&gt; 在函数内优先访问内部声明的变量, 如果没有才会访问外部的. 3&gt; 所有变量的访问规则, 按照预解析规则来访问 案例 var num = 123; function f1 () { console.log( num ); } function f2 () { console.log( num ); var num = 456; f1(); console.log( num ); } f2(); 1&gt; 读取代码预解析. 得到 num, f1, f2 2&gt; 逐步的执行代码 1) 赋值 num = 123; 注意 f1 和 f2 由于是函数, 所以也有数据. 2) 调用 f2. 进入到函数体内. 相当于做一次预解析. 得到 num. 注意, 此时有内外两个 num 执行每一句代码 -&gt; 打印 num. 因为函数内部有声明 num. 所以此时访问的是函数内部的 num. 未赋值, 得到 undefined -&gt; 赋值 num = 456 -&gt; 调用 f1(). 调用函数的规则也是一样. 首先看当前环境中是否还有函数的声明. 如果有直接使用. 如果 没有, 则在函数外面找, 看时候有函数. 此时在函数 f2 中没有 f1 的声明. 故访问的就是外面的 f1 函数 -&gt; 跳入 f1 函数中. 又要解析一次. 没有得到任何声明. -&gt; 执行打印 num. 当前环境没有声明 num. 故在外面找. 外面的是 123. 所以打印 123. 函数调用结束, 回到 f2 中. -&gt; 继续执行 f2, 打印 num. 在 f2 的环境中找 num. 打印 456. 任务: var num = 123; function f1 () { console.log( num ); } function f2 () { console.log( num ); // =&gt; 123 , 456, 456 num = 456; f1(); console.log( num ); } f2(); 案例 (function ( a ) { console.log( a ); var a = 10; console.log( a ); })( 100 ); 拆解 ( 函数 ) ( 100 ) 第一个圆括号就是将函数变成表达式 后面一个圆括号就是调用该函数 var func = function ( a ) { console.log( a ); var a = 10; console.log( a ); } func( 100 ); 注意: 函数定义参数, 实际上就是在函数最开始的时候, 有一个变量的声明 function ( a ) { … } 其含义就是, 在已进入函数体, 在所有操作开始之前( 预解析之前 )就有了该变量的声明. 由于已经有了 a 参数的声明. 所以在代码中 var a = 10 是重复声明. 其声明无效. 所以上面的代码, 等价于 var func = function ( a ) { console.log( a ); // =&gt; 100 a = 10; console.log( a ); // =&gt; 10 } func( 100 ); // 变式 (function ( a ) { console.log( a ); var a = 10; console.log( a ); function a () { console.log( a ); } a(); })( 100 ); 1&gt; 直接调用 2&gt; 进入到函数中, 已有声明 a 并且其值为 100 3&gt; 在函数内部预解析. 得到 一个结论. 函数声明是两个步骤. 1) 让当前环境中, 有变量名 a 可以使用. 但是不需要. 因为已经有 a 的声明了 2) 让 a 指向函数. 相当于 var a; function a () {} ... 4&gt; 开始逐步执行每一句代码 1) 打印 a. 所以打印函数体 2) 赋值 a = 10 3) 打印 a, 打印出 10 4) 如果让 a 调用, 那么报错 error: a is not function 作用域链规则-&gt; 什么是作用域链 链指的就是访问规则 function foo() { console.log( num ); } -------------------- function func () { function foo() { console.log( num ); } foo(); } -------------------- function F () { function func () { function foo() { console.log( num ); } foo(); } func(); } ... ... 由于这种一环套一环的访问规则, 这样的作用域构成一个链式结构. 所以直接称其为作用域链. -&gt; 作用域链是用来做变量查找的. 因此变量可以存储什么东西. 链中就应该有什么东西. 换句话说就是, 链里面存储的是各种对象. 可以将其想象成对象的序列( 数组 ) 绘制作用域链的规则1&gt; 将所有的 script 标签作为一条链结构. 标记为 0 级别的链.2&gt; 将全局范围内, 所有的声明变量名和声明函数名按照代码的顺序标注在 0 级链中.3&gt; 由于每一个函数都可以构成一个新的作用域链. 所以每一个 0 级链上的函数都延展出 1 级链.4&gt; 分别在每一个函数中进行上述操作. 将函数中的每一个名字标注在 1 级链中.5&gt; 每一条 1 级链中如果有函数, 可以再次的延展出 2 级链. 以此类推. 分析代码的执行当作用域链绘制完成后. 代码的的分析也需要一步一步的完成.1&gt; 根据代码的执行顺序( 从上往下, 从左至右 )在图中标记每一步的变量数据的变化2&gt; 如果需要访问某个变量. 直接在当前 n 级链上查找变量. 查找无序.3&gt; 如果找到变量, 直接使用. 如果没有找到变量在 上一级, n - 1 级中查找.4&gt; 一直找下去, 知直到 0 级链. 如果 0 级链还没有就报错. xxx is not defined. 经典面试题 经典面试题的变式( 练习 )写一段代码, 生成 5 个 a 标签. 要求在 a 标签中分别显示出 1, 2, 3, 4, 5即最后得到 12345 闭包的概念-&gt; 字面意义 闭: 关闭, 封闭 包: 包裹, 打包 闭包的含义就是一个被包裹的隔离的空间. -&gt; 在 js 中, 什么是闭包 在 js 中函数是一个具有变量作用域隔离特性的一个内存结构, 即为一个闭包. function foo () { } 学习闭包, 在 js 中到底要解决什么问题在 js 中闭包要解决的问题就是间接的访问到这个被隔离的数据. function foo () { var num = 123; } // 在外界访问到 num 中的数据. 怎么做? 函数, 在 js 中与普通的对象具有一样的意义-&gt; 函数可以像变量一样使用 -&gt; 赋值 -&gt; 传递 闭包的间接访问-&gt; 使用 return 数据不能直接访问原来的数据, 那么可以考虑利用函数的返回访问原始数据 function foo () { var num = 123; // 原始数据 function func () { return num; // 它就是原始数据 num } return func; } 19，当函数声明语法嵌入表达式环境中，会自动进行转换，将转换成函数表达式。 1）引用函数的规则还是使用变量赋值，所以外部可以使用该名字调用函数。 2）函数表达式带有名字，该名字只允许在函数内部使用。属于局部作用域。 3）带有名字的函数表达式，函数的name属性即为该名字。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"html5基础二","slug":"html5第二天","date":"2016-11-28T12:21:49.000Z","updated":"2019-04-26T06:58:30.000Z","comments":true,"path":"2016/11/28/html5第二天/","link":"","permalink":"http://yoursite.com/2016/11/28/html5第二天/","excerpt":"","text":"1,window.addEventListener 2,onLine “L”大写的时候是一个属性，后面不用加括号，直接调用就行，返回一个布尔值。用法:alert（window.navigator.onLine）;返回浏览器是否联网（boolean值）onlone “l”小写的时候是一件事件，这个事件只能用dom二级事件来绑定“navigator”是window上的一个属性，所以写的时候window可以不写，但是建议写上（代码的完整性）online事件在pc端的时候一定是从离线状态变到上线状态的时候才会触发。 2,判断当前设备状态2.1 监听设备在线window.addEventListener(‘online’, function () { // alert(‘online’); $(‘.tips’).text(‘网络已连接’).fadeIn(500).delay(1000).fadeOut(); });delay(时间值)方法 ：是设置延迟时间。 2.2 监听设备离线window.addEventListener(‘offline’, function () { // alert(‘offline’); $(‘.tips’).text(‘网络已断开’).fadeIn(500).delay(1000).fadeOut(); }); 3，html全屏 document.documentElement.webkitRequestFullScreen(); 任意元素全屏显示node.webkitRequestFullScreen();（谷歌浏览器加webkit）node.mozRequestFullScreen();（火狐加moz）任意元素关闭全屏显示Node.cancelFullScreen()（理论是这样关闭实际上是用document.webkitCancelFullScreen()关闭） 兼容写法： function FullScreen(node){ if (node.mozRequestFullScreen){ node.mozRequestFullScreen(); } else if(node.webkitRequestFullScreen){ node.webkitRequestFullScreen(); }else if(node.msRequestFullScreen){ node.msRequestFullScreen(); }else if(node.oRequestFullScreen){ node.oRequestFullScreen(); } } 4，所有元素只能通过document才能调用关闭全屏document.webkitCancelFullScreen(); 4,检测当前是否处于全屏document.webkitIsFullScreen(返回一个boolean值) 5，webkit谷歌浏览器 moz火狐浏览器 msIE浏览器 o欧朋浏览器 6，全屏伪类 .box:-webkit-full-screen { background-color: blue; }（当box全屏的时候，box的背景变为蓝色）:full-screen .box {}、:-webkit-full-screen {}、:moz-full-screen {} 7，状态改变触发事件.change(); 8，base64码。 9，拖拽事件：在HTML5的规范中，我们可以通过为元素增加draggable=”true”来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启的。页面中任何一个元素都可以成为目标元素，不需要特殊指定 9.1、拖拽元素dragstart事件 ：一定是点击加位移才会触发dragend事件 ：一定是位移以后再松开鼠标才会触发拖拽元素开始拖拽以后他的元素会变成光标，松开鼠标以后他会回到原点这段时间，元素会变成本身大小。dragleave事件 ：一定是光标离开拖拽元素的时候才会触发。drag事件 ：只要拖拽开始就一直在不停的触发，直到拖拽结束（期间不管光标是否移动，都会一直触发） 9.2目标元素dragenter事件 一定是光标进入目标元素的时候才触发dragover事件 只要拖拽元素在目标元素内就会触发，无论光标是否移动drop事件 在目标元素内松开鼠标才会触发，但是必须加上dragover事件并且清除dragover事件的默认行为。dragleave事件 在拖拽元素离开目标元素的时候触发，但是一旦我们阻止了dragover事件的默认事件，就不会再松开后触发一个dragleave事件。 11，由于HTML5中我们可以通过为表单元素添加multiple属性，因此我们通过上传文件后得到的是一个FileList对象（伪数组形式）。 12， if（navigator.userAgent.indexOf(“Chrome”) !== -1）{ webkit}else if（navigator.userAgent.indexOf(“Firefox”) !== -1）{ moz} 13,navigator.userAgent获取那个版本。 14，onchange事件 当调用者发生改变是触发。 15，FileReader对象HTML5新增内建对象，可以读取本地文件内容。 var reader = new FileReader; 实例方法：readAsDataURL() 以DataURL形式读取文件事件监听：onload事件reader.onload = function () { document.querySelector(‘img’).src = this.result; } 16，百度地图api使用1、获取当前地理信息navigator. geolocation.getCurrentPosition(successCallback, errorCallback, options)2、重复获取当前地理信息navigator. geolocation.watchPosition(successCallback, errorCallback, options) function success(position) { // alert(1); console.log(position); } // 失败的回调 function error(err) { console.log(&apos;error&apos;); console.log(err); } // 获得用户当前信息 navigator.geolocation.getCurrentPosition(success, error, { // enableHighAccuracy: true, // timeout: 3000, // maximumAge: 1000 }); position.coords.latitude纬度position.coords.longitude经度position.coords.accuracy精度position.coords.altitude海拔高度 17,history.pushState({},’’,’地址’); // 1、对象，在添加历史时，会设置一些数据，一般会设置null // 2、一般不生效，没意义 // 3、我们要更改址址，并且会当一条新记录 history.replaceState({key:123},’’,’地址’);[这里添加的数据在后面onpopstate事件时可以读取和使用]不会新生成网页记录,只是替换当前的地址. // 1、对象，在添加历史时，会设置一些数据，一般会设置null // 2、一般不生效，没意义 // 3、我们要更改址址，并且会当一条新记录 onpopstate()事件 在历史区发生改变后并操作历史区的时候.(历史发生改变后,在操作前进或后退会触发)要绑定给window window.onpopstate = function(state){}为了获取数据加载在页面中以后当我们访问一个网站的时候发现地址发生了改变,网页局部发生了改变,实现网页更新,那么他就用了window.onpopstate事件实现的功能.(主要应用于单页面应用) 18，document.cookie 是一串字符串 19，sessionStorage 同窗口多页面1，是存储在本地的浏览器窗口里，而不是存在地址中2，只要是同一个浏览器窗口，跨页面以后也能得到3，关闭浏览器窗口以后会自动删除4，如果我们换一个浏览器窗口打开就没有了 20，localStorage1，是存储在本地的浏览器中，不再是某一个窗口下，但是不能跨域（传输学医、域名、端口号只要有一个不一样）实现。2，因为是存在浏览器的缓存中，所以关闭浏览器不会丢失数据3，数据消失只能靠手动删除或者清除浏览器缓存 方法：window.localStorage.getItem()（sessionStorage/LocalStorage）：setItem(“key”,”value”)–&gt;设置（sessionStorage/LocalStorage）：getItem(“key”)–&gt;获取，返回value值（sessionStorage/LocalStorage）：removeItem（”key”）–&gt;删除（sessionStorage/LocalStorage）：clear()–&gt;清空（sessionStorage/LocalStorage）：key(0)–&gt;按索引下标查找，返回的是”key”window.localStorage.key(0);获取索引下标为0的值 21,应用缓存:想用应用缓存第一步需要加载进来在manifest文件格式1、顶行写CACHE MANIFEST2、CACHE: 换行指定我们需要缓存的静态资源，如.css、image、js等3、NETWORK: 换行指定需要在线访问的资源，可使用通配符4、FALLBACK: 换行当被缓存的文件找不到时的备用资源 CACHE MANIFEST #版本号 1.0.0 CACHE: #此部分写需要缓存的资源 如.css、image、js等 ./images/img1.jpg./images/img2.jpg./images/img3.jpg./images/img4.jpg./images/img5.jpg NETWORK: #此部分要写需要有网络才可访问的资源，无网络刚不访问(更新最新的内容来代替之前缓存的内容) （记得清缓存） #./js/main.js *代表所有 FALLBACK: 回滚的意思 #当访问不到某个资源的情况下，自动由另一个资源替换 ./css/online.css ./css/offline.css ./online.html ./offline.html当我们找不到源文件就使用备用文件 应用缓存注意事项1、CACHE: 可以省略，这种情况下将需要缓存的资源写在CACHE MANIFEST2、可以指定多个CACHE: NETWORK: FALLBACK:，无顺序限制3、#表示注释，只有当demo.appcache文件内容发生改变时或者手动清除缓存后，才会重新缓存。4、chrome 可以通过chrome://appcache-internals/工具和离线（offline）模式来调试管理应用缓存","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"html5基础","slug":"HTML5总结","date":"2016-11-28T08:15:21.000Z","updated":"2019-04-26T06:57:49.000Z","comments":true,"path":"2016/11/28/HTML5总结/","link":"","permalink":"http://yoursite.com/2016/11/28/HTML5总结/","excerpt":"","text":"HTML5的语法规范html:4s/4t/xs/xt/5 ! 语义化–标签 header footer nav section article aside progress video audio–输入类型 email url tel num search range color time date dateTime week month–表单元素 output meter keygen dataList–表单属性 placeholder autofocus multiple autocomplete novalidate required form pattern 多媒体–audio loop autoplay controls–video loop autoplay controls width height DOM扩展–获取元素 document.getElementsByClassName() querySelector() querySelectorAll()–类名操作 classList.add() classList.remove() classList.toggle() classList.contains()–自定义属性 dataset[key]=’value’ dataset[key] 前缀名“data-*” H5API–online()/offline() 和“onLine”属性 在线状态/离线状态 检测是否在线–fullScreen webkitIsFullScreen检测是否全屏 requestFullScreen（）开启全屏 cancelFulScreen()关闭全屏 注意加前缀（webkit-谷歌，moz-火狐） 关闭全部用document调用 document全屏时写成document.documentElement.requestFullScreen–fileReader 获取的图片信息 ele.files[0] new FileReader() reader.readAsDataURL(图片信息) src赋值–drag 拖拽元素draggable=”true” 默认不可以被拖拽的元素加上这个属性以后就可以被拖拽-- dragstart 拖拽开始 -- dragend 拖拽结束 -- dragleave 光标离开拖拽元素 -- drag 拖拽过程中 目标元素 页面上任意一个元素都可以是拖拽元素，不用特殊设定 -- dragenter 拖拽元素进入目标元素时 -- dragover 拖拽元素在目标元素内 -- dragleave 拖拽元素离开目标元素 -- drop 拖拽元素在目标元素内松开鼠标 地理定位– geolocation.getCurrentPosition(successCallback, errorCallback, options)– geolocation.watchPosition(successCallback, errorCallback, options)– 成功回调是我们能得到一个positionposition.coords.latitude纬度 position.coords.longitude经度 position.coords.accuracy精度 position.coords.altitude海拔高度 – 失败回调我们能得到一个error 里面写的是错误信息– 使用百度的API接口 history– history.pushState(null,’’,’地址’)– history.replaceState(null,’’,’地址’)– onpopstate()事件 在历史区发生改变后并且操作历史区的时候 web存储– sessionStorage 同窗口多页面保存数据 关闭窗口后删除– localStorage 多窗口保存页面 不会自动删除，只能手动删除setItem(&quot;key&quot;,&quot;value&quot;) 增加或更改 getItem(&quot;key&quot;) 获取 removeItem(&quot;key&quot;) 删除 clear() 清空 key(0) 按照下标回去，返回的是“key” 应用缓存，配置静态资源文件CACHE MANIFEST 版本号CACHE: 需要缓存的资源 NETWORK: 当网络重新连接时需要重新获取的资源 FALLBACK: （源文件）\\s（备用文件）当我们找不到源文件的时候启用备用文件 10,jquery视频编写1,oncanplay()检测视频可以播放时触发2,video.duration获取视频的总时长3,video.paused判断视频播放还是暂停4,toggleClass切换按钮状态5,video.currentTime获取当前的播放进度 11,分隔字符串返回数组方法为 str.split(“分隔符”) 分隔符为: , 等.","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}