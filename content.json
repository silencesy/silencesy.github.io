{"meta":{"title":"Silence","subtitle":null,"description":"个人微博","author":"Silence","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"seajs和requirejs","slug":"seajs  and requirejs","date":"2017-03-04T04:50:07.000Z","updated":"2017-03-04T04:50:07.000Z","comments":true,"path":"2017/03/04/seajs  and requirejs/","link":"","permalink":"http://yoursite.com/2017/03/04/seajs  and requirejs/","excerpt":"","text":"##为什么要使用模块化 全局变量、全局函数，容易造成变量名冲突 页面引入了一堆的js文件，存在先后顺序的问题 代码由于组织混乱很容易出错 出错了很难调试 后期难以维护 模块化的好处 提升开发效率 便于后期维护 ##模块化理解模块化是一种组织代码的方式，当我们的项目越来越复杂的时候，如果把很多功能业务逻辑写在一起，就会造成开发起来十分的繁琐(因为经常会遇到变量命名冲突、文件依赖过于混乱的问题)，同时维护起来也十分的麻烦，这时候，我们可以考虑把代码按照功能等方面把整个项目划分成一个一个的模块，这样，当我们开发的时候，我们每次只需要关注这一小功能点是如何实现的，从而简化了开发的难度，这样可以提高我们开发的效率，同时，后期维护起来也会变得更加的简单。 ####cmd规范特性 一个模块就是一个单独的文件 由于每个模块都是属于define关键字函数的回调函数被调用，每个模块都是一个单独的作用域 预加载、懒执行（预加载就是预先把所有的模块全部加载完，懒执行就是需要执行哪块才执行哪块） ####关键字 define 定义一个模块 require 加载一个模块 exports 暴露一个模块 module 模块 ####注意点 define(function(require,exports,module){});这里面的require,exports,module三个参数的名字是固定写法，不能简写，顺序不能错了 记忆方法：rem 如果define里的参数想省略，只能从后面开始省略，只要写了后面的，前面的必须要写上 –&gt; 推荐写全，不要省 如果一个模块既不需要公开成员变量，也不需要依赖第三方模块，那么可以全部省略 seajs.use(“入口模块”)可以加回调函数，形式如：seajs.use(“入口模块”,callback); ####路径问题 在sea.js当中，js/main和./js/main的含义不是一样的 js/main代表的是在sea.js所在的文件为基准去找，所以找到的是 –&gt; SEAJS所在的父级文件夹/js/main.js 这样的话会找不到的(相对seajs包的路径) ./js/main代表的是以当前html文件去找js文件夹下面的main.js require(“xxx”) –&gt; 其实这里的xxx叫模块标识，不是路径 config的作用就是为了简化调用模块 base 设置路径 alias 设置模块的别名，简化调用 ##seajs使用 ####1. 引包 ####2. 入口模块 //为了简洁，路径最好不加.js //加载完成后触发回调函数 //简化调用模块 seajs.config({ //base 设置路径 //alias 设置模块的别名，简化调用 base:”./js” alias:{ m:”main” } }) seajs.use(“./js/main”,function(){ console.log(‘代码执行成功’); }); ####3. 主模块 // 名字写全 并且顺序和单词都要写对（便于记住rem） define(function (require, exports, module) { // require 方法得到的就是指定的模块中向外暴露的接口对象 module.exports // var fooModule = require(‘./foo’) // console.log(fooModule.foo) var foo = require(‘./foo’) console.log(foo) }); ####4. 第三方模块 define(function (require, exports, module) { // 每个文件模块都是一个模块作用域，外部是无法直接拿到的里面的东西的 var foo = ‘bar’; // 默认情况下 module.exports 就是一个空对象 // module.exports.foo = foo module.exports = &apos;bar&apos;; }); ####sea.js把非cmd模块转换成cmd模块 // 判断的左右就是防止jquery不作为cmd模块使用的时候也可以用 if (typeof define === ‘function’ &amp;&amp; define.cmd) { define(function(require,exports,module){ module.exports = jQuery; }); } ##require.js ####引包 //data-main引入主模块包 //如果想用jQuery,则必须配置如下： require.config({ baseUrl:&apos;./js/app/&apos;,//这里设置的是main的路径 paths:{ &quot;jquery&quot;:&quot;../lib/jquery&quot; } }); ####main //类似angular //[‘./cal’]映入第三方模块 requirejs([‘./cal’],function(calculator){ }); ####第三方模块 define(function(){ //用return 提供接口暴露数据 return });","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"签看css3","date":"2017-02-27T14:18:38.000Z","updated":"2017-02-27T14:18:38.000Z","comments":true,"path":"2017/02/27/签看css3/","link":"","permalink":"http://yoursite.com/2017/02/27/签看css3/","excerpt":"","text":"**如何使用手册** 学会使用工具，可以让我们事半功倍。 [] 表示全部可选项 || 表示或者 | 表示多选一 ？ 表示0个或者1个 * 表示0个或者多个 {} 表示范围 一、选择器 1.属性选择器： –ele[attr] 选取包含这个属性的元素 –ele[attr=value] 选取这个attr属性有且只有value这一个值的元素 –ele[attr^=value] 选取这个attr属性中以value字符开头的元素 –ele[attr$=value] 选取这个attr属性中以value字符结尾的元素 –ele[attr*=value] 选取这个attr属性中以包含value字符的元素 –ele[attr~=value] 选取这个attr属性中有value这个属性值的元素 2.伪类选择器： –ele:first-child 选取当前元素的父级下的第一个子元素 –ele:last-child 选取当前元素的父级下的最后一个子元素 –ele:nth-child(xn+y) 选取当前元素的父级下的第xn+y个子元素 –ele:nth-last-child(xn+y) 选取当前元素的父级下的倒数第xn+y个子元素 –ele:empty 选取当前元素下没有任何子元素或文本的元素（注释不算，但是空格算 通常用在购物车计数） –ele:not(.class) 选取的是除了这个元素之外的元素 –ele:target 处在锚点状态下的元素（也就是当前元素被锚点状态） –ele:checked 选取的是当前处在checked状态下的元素（用于input标签中的单选和复选框） –ele:enabled 选取的是当前处在enabled状态下的元素（用于按钮） –ele:disabled 选取的是当前处在disabled状态下的元素（用于按钮） 3.伪元素选择器： –ele:before/ele::before 在当前元素下添加一个before伪元素处在当前元素下最开始的位置 –ele:after/ele::after 在当前元素下添加一个after伪元素处在当前元素下最末尾的位置 element::before/element::after { content:’’; 这里可以填内容 通常为空(如果设置文本内容,则会在该伪元素上显示文本内容) display:block; 新建的伪元素是一个行内元素,在使用的时候通常转换为块级元素,但是不一定要转换(也可以通过定位或者浮动来改变成块级元素) width:; height:; … } --ele::first-letter 当前文本的首字母（也可以是第一个字） --ele::first-line 当前文本的第一行（是相对的） --ele::selection 设置选中区域的样式(可以设置字体颜色和背景颜色等,但是不可以改变字体大小) --input::-webkit-input-placeholder{}选中input里的placeholder并设置样式 注意:伪元素选择器前面的两个点最好写成一个,以为现在的浏览器默认会添加成两个. 4.小技巧 -webkit-user-select:none;当前元素下的文字不可选中 二、颜色 1.color属性可以赋什么值 – red 直接写代表颜色的英文单词 – #CCCCCC 16进制表示方法 – rgb(0,0,0) 三个参数值分别是0-255，0-255，0-255 – rgba(0,0,0,0) 四个参数值分别是0-255，0-255，0-255,0-1最后一个参数表示透明度，不会被其子盒子继承 – hsl(0,0%,0%) 三个参数值分别是0-360，0%-100%，0%-100% – hsla(0,0%,0%,0) 四个参数值分别是 色调0-360,饱和度0%-100%(但这个参数为0的时候,必须为0%才不会出错)，亮度0%-100%,0-1最后一个参数表示透明度，不会被其子盒 子继承 -- transparent 完全透明的意思，不可以调节透明度 2.opacity 表示透明度的意思，取值为0-1之间的数字，会被子盒子继承 三、文字阴影 1.text-shadow: 0px 0px 0px red 文字阴影 – 第一个参数表示阴影左右移动的距离（正值向右，负值向左） – 第二个参数表示阴影上下移动的距离（正值向下，负值向上） – 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊 – 第四个参数表示阴影颜色 (后面可以在用逗号,在添加一个文字阴影.)四、边框 1.border-radius: 0px 0px 0px 0px / 0px 0px 0px 0px 边框圆角（可以是正圆角也可以是椭圆角，当X/Y轴半径不一样的时候即为椭圆角，如果X/Y轴半径一样，那么“/”后 面的值可以省略不写） – 0 0 0 0 / 0 0 0 0; 标准写法 分别表示1、2、3、4 位置的X/Y轴半径 – 0 0 0 / 0 0 0; 简写 分别表示 1、2/4、3 位置的X/Y轴半径 – 0 0 / 0 0; 简写 分别表示 1/3、2/4 位置的X/Y轴半径 – 0 / 0; 简写 表示四个位置的X/Y轴半径 2.box-shadow: 0px 0px 0px red 盒子阴影 – 第一个参数表示阴影左右移动的距离（正值向右，负值向左） – 第二个参数表示阴影上下移动的距离（正值向下，负值向上） – 第三个参数表示阴影的模糊度，不能为负值，数值越大阴影越模糊 – 第四个参数表示阴影颜色 3.border-image: url(“”) 27 stretch repeat 边框背景图片（复合属性，也可以拆开写） – 第一个参数表示边框背景图片的引入地址 – 第二个参数表示引入的图片中以什么样的尺寸来分割成九份 – 第三个参数表示X轴方向的填充方式（round，repeat，stretch） – 第四个参数表示Y轴方向的填充方式（round，repeat，stretch） – border-image-source: url(“”); – border-image-slice: 27 27 27 27 fill;（背景图片裁切尺寸，最后的fill是表示中间内容区域也显示为图片的中间区域，如果不写默认为中间内容区域留白） – border-image-repeat: stretch repeat round; – border-image-width: 20px; – border-image-outside:1/0px;虚拟变大,只是占以前的大小,不会影响旁边的元素 .设置的值有两种, 数字代表扩大自己的倍数 ,具体的像素. 说明: stretch拉伸 repeat平铺(两边会被裁剪) round显示全部浏览器自动调整 五、盒模型 1.box-sizing:border-box （以边框方式计算盒子的大小） – border-box 设置为border-box以后，我们设置的盒子（width/height）即为content+padding+border – content-box 设置为border-box以后，我们设置的盒子（width/height）即为content（默认） 说明: 默认的box-sizing:content-box;优先保证内容的大小 对盒子进行缩放. box-sizing:border-box;让盒子优先保证自己所占域的大小,对内容进行压缩.六、背景 1.background-size: 10px 10px 背景图片的尺寸大小（也可以设置为contain、cover） –contain 图片两边等比例拉伸，直到某一边顶格停止拉伸（长边位置顶格后，短边位置不再拉伸，其余位置留白） –cover 图片等比例拉伸，保证两边都顶格，可能会出去（短边位置顶格，长边位置溢出盒子） 2.background-position: 10px 10px/top left 背景图片定位 3.background-origin: 背景图片的开始位置 –border-box 让图片背景在border开始的位置开始显示 –padding-box 让图片背景在padding开始的位置开始显示（默认） –content-box 让图片背景在content开始的位置开始显示 4.background-clip: –content-box 内容区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切） –padding-box padding区域以外的背景图片全部裁切掉（不是图片缩小或移动位置，而是直接裁切） 5.background-image –background-image:url(“”),url(“”),…,…; 多张背景图片以逗号分隔可以引入多张背景图片 –background-position:top left,top left;当设置了多重背景时要设置背景位置时也用逗号隔开设置,其位置时一一对性的. 七、渐变 1.linear-gradient() 线性渐变 –第一个参数表示线性渐变的方向（to top/right/bottom/left，也可以是具体的角度360deg） –第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%） –第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少,为什么颜色） –第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写） –…… 2.radial-gradient() 径向渐变 –第一个参数表示径向渐变的范围（为半径值） –第二个参数表示径向渐变的开始位置（at 渐变开始的位置，也可以是具体的值） –第二个参数表示从什么颜色开始（也可以在颜色后面加上百分比 yellow 25%） –第三个参数表示向什么颜色渐变（根据上一个百分比来决定从多少到多少为什么颜色） –第四个参数表示向什么颜色渐变（从第四个开始可以写可以不写） –…… 3.http://www.colorzilla.com/gradient-editor/ 自动生成全兼容渐变代码 具体说明: 1,渐变 1.1线性渐变 background-image:linear-gradient(to right,yellow,green);黄色从左到右渐变为绿色 方向还可以用度数但是要带单位deg 0deg向上 90deg向右 background:linear-gradient(90deg,yellow 25%,green);开始%25是黄色不开始渐变,过了%25之后才开始渐变(这个百分比相当于 整个盒子)background:linear- gradient(90deg,yellow 25%,green 50%); 还可以个多个值:例如 background:linear-gradient(90deg,yellow 25%,green 25%m,pink 50%); 方向 颜色 范围 1.2径向渐变 有原点(圆心) 两种颜色 background-image:radial=gradient(120px at center center,yellow,green); 第一个参数是半径 后面两个是坐标 左后是颜色 background-image:radial=gradient(120px 80px at center center,yellow,green); 写了两个半径就是椭圆 后面坐标可以用单词 给百分比 和具体的数值 background-image:radial=gradient(120px 80px at center center,yellow,green 25%,blue);和线性渐变基本一样 总结注意:要想不要渐变的效果就这样设置background:linear-gradient(90deg,yellow 25%,green %25,green 50%) ;八、过渡动画 1.transition: all 1s 1s ease 过渡动画（从其实状态到结束状态的改变，只能是两个这状态的改变） –后面参数的书写顺序没有具体规定，不过出现的第一个时间一定是过渡需要的时间，第二个才是延迟时间 –一般大家默认写成（属性、过渡时间、延迟时间、线性） –第一个参数为transition-property 是我们需要的过渡的属性（可以是单一的某一个，如果全部都过渡就写all） –第二个参数为transition-duration 是完成本次过渡动画的总时间 –第三个参数为transition-delay 是本次动画开始是的延迟时间 –第四个参数为transition-timing-function 是本次动画的动画线性（默认为ease） 2.http://cubic-bezier.com/#.17,.67,.83,.67 生成过渡线性（贝塞尔曲线） 说明:动画线性的其他值 linear： 线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) ease： 平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) ease-in： 由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease-out： 由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in-out： 由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) 这里注意如果transition: all 1s 1s ease加在element:hover触发的时候就只会执行一次动画 加在element的时候会执行两次动画 九、2D转换 所有2D转换都是transform属性，只不过后面的值不一样 1.transform: translate 2D转换中的位移 –translateX(20px) 向X轴正方向移动20px –translateY(20px) 向Y轴正方向移动20px 2.transform: scale 2D转换中的缩放 –scaleX(1) 延X缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位） –scaleY(1) 延Y缩放1倍（1为没有缩放，大于1就是放大，小于1就是缩小，不可为负值，没有单位） 3.transform: rotate 2D转换中的旋转 –rotate(360deg) 旋转一定的角度（即在Z轴上旋转，正值为顺时针，负值为逆时针）注意:transform-origin:top right;绕具体位置旋转(值可以为坐标单词和具体的像素值) 4.transform: skew 2D转换中的倾斜（扭曲） –skewX(360deg) 顺着X轴进行倾斜（不常用） –skewY(360deg) 顺着Y轴进行倾斜（不常用） 注意:transform:translatex(x); transform:translatex(y); 上面这样写法,后面会覆盖前面的,当两个都要写的时候就这样写transform:translatex(x) translatex(y); 十、3D转换 1.transform: translate 3D转换中的位移 –translateX(20px) 向X轴正方向移动20px –translateY(20px) 向Y轴正方向移动20px –translateZ(20px) 向Z轴正方向移动20px 2.transform: rotate 2D转换中的旋转 –rotateX(360deg) 旋转一定的角度（延X轴进行一定的角度旋转） –rotateY(360deg) 旋转一定的角度（延Y轴进行一定的角度旋转） –rotateZ(360deg) 旋转一定的角度 ( 延Z轴进行一定的角度旋转 ) 注意:transform:rotate3d(1,1,1,45deg)前面三个一 正的正着转 负的反着转 3.transform-origin: left bottom 改变旋转轴的位置 第一个参数可以为 top bottom left right 第一个参数可以为 top bottom left right 这里的参数还可以设置像素值 4.transform-style: preserve-3d 设置在父级盒子上，让其子元素在3D效果下 5.perspective: 600px 进行600px距离的透视效果，距离越大效果越不明显 注意:我们可以同时使用多个转换，其格式为：transform: translate() rotate() scale() ...等，其顺序会影转换的效果。 当在设置动画的时候如果元素本身设置了transform的属性时 如translate() rotate(); 那么在hover的时候要与元素本身的transform属性一一对应顺序才能正确的显示 具体例子 如:.rocket { height: 190px; width: 100px; position: absolute; bottom: 0; transform: translate(0, 0) rotate(30deg) ; transition: transform 1s; } section:hover .rocket{ transform:translate(1000px, -500px) rotate(900deg) ; } 十一、帧动画 1.@keyframes 名字{} 是指动画的定义阶段，里面会写明动画在各个阶段会变换成什么样子 –{ from{ from中如果不设置,默认使用的是,初始状态 } to{ to中设置的是结束时的状态 } } –{ 0%{ 0%中如果不设置,默认使用的是,初始状态 } 50%{ 50%中设置的是动画中50%帧位置时的动画，当然也可以写的更加细致 } 100%{ 100%中设置的是结束时的状态 } } 2.animation-name: 名称; 与我们定义动画的时候名字配套，是指我们本次动画使用我们定义的哪一个动画 3.animation-duration: 2s; 持续时间，是指我们的本次动画要多少时间完成 4.animation-delay: 2s; 延迟时间，是指我们的本次动画在最开始的时候延迟多少时间后开始 5.animation-iteration-count: infinite; 执行次数，是指本次动画执行多少次，infinite为无限 6.animation-timing-function: linear; 是指动画执行的线性(step(5)分布执行) 7.animation-fill-mode: forwards; 是指动画结束时的状态 –backwards：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后回到最原始状态 –forwards：动画从最原始状态开始，而不是第一帧，动画结束后就留在最后的状态 –both：动画开始状态是从动画的第一帧开始而不是原始状态开始，动画结束后就留在最后的状态 8.animation-direction: normal; 是指动画执行的顺序，在多次执行动画时设置 –normal 是指每次动画都是正向执行 –reverse 是指每次动画都是反向执行 –alternate 是指多次动画时以正向开始，并以（正、反、正…）的顺序执行下去 –alternate-reverse 是指多次动画时以反向开始，并以（反、正、反…）的顺序执行下去 9.animation-play-state: running; 是指动画的暂停与播放 –running 是指动画播放 –paused 是指动画暂停 (用js暂停动画dom.style.animationPlayState=’paused’;) 10,连写习惯:名称 持续时间 线性 次数 顺序 结束状态 运动和暂停 连写注意: 复合写法 1属性的顺序是可以随意调换的 2第一次出现的时间是动画持续时间 3第二个出现的时间是延迟时间 4如果只设置一个时间 默认就是动画持续事件十二、flex弹性盒子 1.display: flex 设置在父级盒子上，表示开启弹性布局，开启后其子元素会拥有一个主轴，一个侧轴，主轴默认是X轴方向是从左向右，侧轴垂直于主轴，默认方向是从上向下 2.justify-content: flex-start; 设置在父级盒子上，表示主轴方向上的分布排列 –flex-start 这是默认值，是从开始位向结束位依次排列 –flex-end 是从结束位向开始位依次排列 –center 是居中显示 –space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等 –space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍 说明:space-between 左右靠边,中间间歇相等排布,父盒子的宽度减去所有子盒子的宽度除以(盒子-1)让左右盒子的靠边,其他盒子中间就插上刚刚所算出来的值 space-around左右间歇相等 父盒子的宽度减去所有自盒子的宽度再除以所有盒子*加在每个盒子的两侧 3.align-items: stretch; 设置在父级盒子上，表示对侧轴方向上的分布排列，这是在只有一行的时候使用 –stretch 表示其下的子盒子会在侧轴上进行拉伸至上下顶格，会和我们元素本身的宽和高有冲突 –flex-start 排在开始位 –flex-end 排在结束位 –center 是居中显示 4.align-content: flex-start; 设置在父级盒子上，表示对侧轴方向上的分布排列，这是在多行的时候使用(注意当只有一行的时候无法生效) –flex-start 是从开始位向结束位依次排列 –flex-end 是从结束位向开始位依次排列 –center 是居中显示 –space-between 是从开始位向结束位依次排列，左右顶格，所有元素中间的间隙相等 –space-around 是从开始位向结束位依次排列，左右不顶格，最左则元素的左边间隙和最右边元素的右边间隙相等，所有元素中间的间隙为左右两侧的二倍 5.flex-direction: row; 改变主轴的方向 –row 是默认值，是主轴从左到右的方向排列,开始位在最左侧 –column 是主轴从上到下的方向排列，开始位是最上方 –row-reverse 是主轴从右到左的方向排列,开始位在最右侧 –column-reverse 是主轴从下到上的方向排列，开始位是最下方 6.flex-wrap:nowrap; 是否允许换行 –nowrap 是不允许换行，是默认值 –wrap 是允许换行 7.align-self: flex-start; 设置在子盒子上，是表示当前元素在当前侧轴上所处的位置 –flex-start 排在开始位 –flex-end 排在结束位 –center 是居中显示 8.order: 1; 设置在子元素上，表示子元素的顺序，按照从大到小的顺序排列，不写的话默认为1 9.flex: 1; 设置在子元素上，表示子元素在父盒子中主轴方向上所占的比重 零碎知识点:1,-webkit-user-select:none;设置某元素的文字不能被选中.2,实现自定义三角形.box { height: 0; width: 0; border: 50px solid; border-color: yellow transparent transparent transparent; margin: 50px auto}3,position:absolute; top:0; left:0; right:0; bottom:0;相当于height:100%;width:100%;但是元素必须加绝对定位 4,backface-visibility:hidden;后面隐藏 demo总结 360案列总结:引用插件fullPage和jquery $(function(){ $(‘#safe’).fullpage({ afterLoad:function(anchorLink ,index){ // 删掉所有的 animationclass $(‘.section’).removeClass(‘animation’); // 为当前页添加animationclass // 首页 默认执行的速度太快了 还没看到 就执行完毕了 所以延迟一点 setTimeout(function(){ $(‘.section’).eq(index-1).addClass(‘animation’); },10) } }); }) &lt;/script&gt; 复制页面结构 第一屏 第二屏 第三屏 第四屏 注意:1,这里每页的名字必须为section,如果需要其他类名可以在后面添加.2,由于插件会在每页我们自动生成一个div,便于我们添加弹性布局 设置动画的时候书写格式.two .shield img:nth-child(5){ transform: rotateZ(45deg) translate(200px,100px);}.two.animation .shield img:nth-child(5){ transform: rotateZ(0deg) translate(0,0); transition: all 1s;}原理为当整屏滚动的时候删除所有名为animate的类名,然后再添加类名为animate的类名,实现动画. animation动画总结1,定义动画@keyframes name{ 0%{} 25%{} 50%{} 75%{} 100%{}}那个元素要使用动画就添加动画animation:name …; 切割轮播图总结:","categories":[],"tags":[],"keywords":[]},{"title":"HTML5的表单","slug":"html5表单","date":"2017-02-21T14:55:22.000Z","updated":"2017-02-21T14:55:22.000Z","comments":true,"path":"2017/02/21/html5表单/","link":"","permalink":"http://yoursite.com/2017/02/21/html5表单/","excerpt":"","text":"##HTML5的表单 HTML5的第二个大特点就是他的各种表单控件，也是非常强大的功能。 输入类型 输入类型，顾名思义就是我们在写input标签时type后面的属性值，我们以前接触的有 &lt;input type=&quot;text&quot;&gt;//-&gt; 文本框 &lt;input type=&quot;password&quot;&gt;//-&gt; 密码框 &lt;input type=&quot;checkbox&quot;&gt;//-&gt; 复选框 &lt;input type=&quot;radio&quot;&gt;//-&gt; 单选框 &lt;input type=&quot;submit&quot;&gt;//-&gt; 提交 &lt;input type=&quot;button&quot;&gt;//-&gt; 按钮 &lt;input type=&quot;reset&quot;&gt;//-&gt; 重置 &lt;input type=&quot;file&quot;&gt;//-&gt; 文件选择 这些都是我们以前的输入类型，但是对于今天的开发，这些类型已经不够用了，我们需要更多更细致的分类 &lt;input type=&quot;email&quot;&gt;//-&gt; email地址匹配 &lt;input type=&quot;url&quot;&gt;//-&gt; url地址匹配 &lt;input type=&quot;tel&quot;&gt;//-&gt; 电话号码 &lt;input type=&quot;number&quot;&gt;//-&gt; 数字 &lt;input type=&quot;search&quot;&gt;//-&gt; 搜索框 &lt;input type=&quot;color&quot;&gt;//-&gt; 拾色器 &lt;input type=&quot;time&quot;&gt;//-&gt; 时间选择 &lt;input type=&quot;date&quot;&gt;//-&gt; 日期选择 &lt;input type=&quot;month&quot;&gt;//-&gt; 月份选择 &lt;input type=&quot;week&quot;&gt;//-&gt; 周选择 这些新加入的输入类型，大大的降低了我们的代码量。比如，email框，以前我们要是想让这个框里输入的一定是email地址的话，我们需要用JS获取这个input框的value，然后写一段正则来匹配，最后在返回结果。而现在我们只需要在HTML中写个email类型的input框就可以了。 当然了，这里面有一些是针对移动设备的，并且有兼容性问题，所以我们在开发过程中一定要根据需求选择性的来使用。##表单元素 表单元素其实就是HTML5中新增加的一些属于表单的新标签。 以前我们接触的表单元素有 &lt;form&gt;&lt;/form&gt;//-&gt; 表单 &lt;fieldset&gt;&lt;/fieldset&gt;//-&gt; 表单框 &lt;legend&gt;&lt;/legend&gt;//-&gt; 表单框的标题 &lt;label&gt;&lt;/label&gt;//-&gt; 表单里的控件标签 &lt;textarea&gt;&lt;/textarea&gt;//-&gt; 文本区域 &lt;select&gt;&lt;/select&gt;//-&gt; 选择列表 &lt;option&gt;&lt;/option&gt;//-&gt; 选择列表的下拉项 下面是我们HTML5中新增加的表单元素&lt;datalist&gt;&lt;/datalist&gt;//-&gt; 数据列表 &lt;output&gt;&lt;/output&gt;//-&gt; 输出结果 &lt;meter&gt;&lt;/meter&gt;//-&gt; 度量器 &lt;keygen&gt;&lt;/keygen&gt;//-&gt; 生成加密字符串 这些都是为了我们的开发效率更快而诞生的，大家只需要记住就好。 ####表单属性 表单属性就是对于一些表单元素的修饰，因为光靠现在的表单输入类型加上现有的表单元素，还是不能满足我们的各式各样的需求，所以就需要在依靠表单属性来帮我们做一些小细节的处理。 比如：我们要一个文本框只能输入数字，以前只能靠一小段JS代码来实现，现在可以直接用“input type=”number””就可以了，但是如果我只想让他输入10到20之间的数字的时候，就必须要表单属性来帮助了。 &lt;input type=&quot;number&quot; min=&quot;10&quot; max=&quot;20&quot;&gt; 这样的话就只能填写10到20之间的数字了。 以前我们还接触过很多表单属性，比如value等，我们就不意义列举了，直接介绍一下HTML5新增的属性 placeholder//-&gt; 占位符 autofocus//-&gt; 自动获取焦点 multiple//-&gt; 多文件上传 autocomplete//-&gt; 自动填充 form//-&gt; 表单关联 novalidate//-&gt; 关闭验证 required//-&gt; 必填 pattern//-&gt; 自定义验证 通过这些表单属性，我们可以在HTML页面更加细致的处理一些表单的细节，而不需要借助JS。做到了节约性能。","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"html5标签兼容性","date":"2017-02-21T14:32:13.000Z","updated":"2017-02-21T14:32:13.000Z","comments":true,"path":"2017/02/21/html5标签兼容性/","link":"","permalink":"http://yoursite.com/2017/02/21/html5标签兼容性/","excerpt":"","text":"##HTML5的兼容性 因为在IE8及一下的IE版本是不兼容HTML5的新元素的，所以我们要是用HTML5开发的话，第一个要解决的就是兼容性的问题。HTML5的兼容性 因为HTML5的新元素就是一些新的标签，IE只是不认识这些标签而已，那我们解决的问题就是让IE8一下版本的浏览器认识这些标签，或者说知道他就是一个标签，那么我们就解决了兼容性问题。比如：header 这个标签在IE8及一下的版本的浏览器中是不认识的，但是我们却可以通过一小段JS代码来创建标签，通过JS来创建的标签浏览器是可以识别的，我们就可以利用这个点来解决兼容性问题。这里就需要用到一个方法，document.createElement(); var oHeader = document.createElement(&quot;header&quot;);//-&gt; 动态创建一个标签‘header’document.body.appendChild(oHeader)//-&gt; 把header标签动态添加到body中这样添加以后我们就可以在IE8下使用header标签了。但是，我们不确定我们的每一次开发中到底使用多少个header标签，也不确定具体要什么时候使用，如果说我们每一次使用的时候都写一小段JS代码来动态创建和动态添加的话，那就会很耗性能，所以我们只需要在最开始告诉浏览器一声，我创建了一个header标签就可以，至于什么时候用浏览器你就别管了，反正只要出现了这个标签你知道他是什么，会渲染他就可以了，我们就可以这样写 document.createElement(&quot;header&quot;);这样就可以了，以后你再使用header标签的时候，浏览器就会知道，他是一个标签，我就按照标签的标准来渲染他就行了。但是第二个问题出现了，那就是我们也不知道我会在这次开发中都使用到哪些个HTML5的标签，那么我们就把每一个HTML5标签都声明一遍就可以了。 这里就不用我们自己来写了，只需要引入一个JS文件就可以了。就是 “html5shiv.min” 这个文件，里面已经帮我们把所有的都写好了，就不用我们每回自己写了。这个时候出现了第三个问题，那就是我们引入了这个JS文件以后，那么不管这个浏览器是不是兼容HTML5标签，我们都声明了一遍，也就是说我们这一段JS代码都运行了，当然，这样做是没有问题的，可是这样对于已经可以兼容HTML5的浏览器来说就是浪费了，虽然这个文件很小，但是也会浪费一定的性能，作为一个开发人员来说，没一个KB的性能都是能省就省，尽量不出现一个多余的KB。所以，我们就只要让这个JS文件在IE8及以下版本的浏览器中运行就行了，这个时候我们就需要一种方法： 这个注释的意思是，当浏览器是IE8及以下的版本的时候，才执行中间的代码。 只有在IE8及一下版本的浏览器中，才会执行这个“alert(123)”这个命令，而其他的浏览器不会执行这一段代码。 所以我们可以用这个方法来引入刚才那段JS代码 这样就可以做到只在不兼容HTML5的浏览器中进行声明，而兼容的浏览器则直接跳过，这样做即解决了兼容性问题，也进行了性能优化。","categories":[],"tags":[],"keywords":[]},{"title":"angular路由使用","slug":"angular路由使用","date":"2017-02-21T08:00:45.000Z","updated":"2017-02-21T08:00:45.000Z","comments":true,"path":"2017/02/21/angular路由使用/","link":"","permalink":"http://yoursite.com/2017/02/21/angular路由使用/","excerpt":"","text":"##angular路由使用 ####安装angular-route npm install angular-route –save####引用模块 &lt;script src=&quot;node_modules/angular-route/angular-route.js&quot;&gt;&lt;/script&gt;####创建模块 var app = angular.module(&#39;myApp&#39;,[&#39;ngRoute&#39;]);####使用规则 //有一个参数：类似于controller的第二个参数 //需要注入一个参数$routeProvider 这个参数是用来设置具体的规则的 app.config([‘$routeProvider’,function($routeProvider){ // 路由参数： // when方法，第一个参数是当前url中锚点值 // 第二个参数是一个object对象 并且可以通过.实现链式编程 从而实现多个筛选（不过一般使用路由参数动态的实现筛选） // 当我们满足这样的规则的时候就会把模板的内容插入到页面插入有ng-view属性的标签的innerHTML //路由参数’/students/:name?’这里加?（0-1）个参数 让参数可控 当/后面没有内容的时候也走这个规则 $routeProvider.when(&apos;/students/:name?&apos;,{ //模板 template/templateUrl template:&apos;&lt;p&gt;{{nowStu.id}},{{nowStu.name}},{{nowStu.grade}}&lt;/p&gt;&apos;, // 指向一个控制器的名字 最终我们需要在这个模板中使用一些数据模型 controller:&apos;stuController&apos; //otherwise 当上面的when都没有匹配的时候 就走这里面 需要一个参数 是一个对象 }).otherwise({ //当前面所有的when都不满足时 就会跳转到这个指定的锚点值页面 redirectTo:&apos;/students/&apos; }) //创建控制器 //控制器暴露的数据能够在template中使用 //$routeParams是一个对象 获取url中想要匹配的值 如 {name:&quot;zhangsan&quot;} //$route监视url参数的变化 app.controller(&apos;stuController&apos;,[&apos;$scope&apos;,&apos;$routeParams&apos;，&apos;$route&apos;,function($scope,$routeParams,$route){ $scope.students = { zhangsan: {id: 0, name: &quot;张三&quot;, grade: &quot;一年级&quot;}, lisi: {id: 1, name: &quot;李四&quot;, grade: &quot;一年级&quot;}, xiaobai: {id: 2, name: &quot;小白&quot;, grade: &quot;一年级&quot;}, wangwu: {id: 3, name: &quot;王五&quot;, grade: &quot;一年级&quot;}, zhaosi: {id: 4, name: &quot;赵四&quot;, grade: &quot;一年级&quot;}, } //动态暴露数据 为了让路由中的模板使用 $scope.nowStu = $scope.students[$routeParams.name]; //当用户输入的数据没有的时候就会默认跳转到摸个数据上进行显示 if($scope.nowStu){ //$scope.nowStu=$scope.students[&apos;lisi&apos;]; //$route提供一个方法 默认会跳转到lish的信息 //updateParams他只能改&apos;/students/:name?&apos;中name的值 $route.updateParams({name:&apos;lisi&apos;}); //如果要改urL整个的值 需要使用$location.url(&apos;/sunyu/&apos;) 但是注意$location.url获取的锚点值不包括# $location.url(&apos;/sunyu/&apos;)； } }]);","categories":[],"tags":[],"keywords":[]},{"title":"git续篇","slug":"git续编","date":"2017-02-18T08:47:55.000Z","updated":"2017-02-18T08:47:55.000Z","comments":true,"path":"2017/02/18/git续编/","link":"","permalink":"http://yoursite.com/2017/02/18/git续编/","excerpt":"","text":"流行框架第2天git使用ssh方式上传代码与github git生成公钥和私钥 命令:ssh-keygen -t rsa生成的公钥与私钥文件会在当用户目录的.ssh目录下. 把代码push到服务器时需要先pull一下 在pull之后如果远程的代码与本地的代码有冲突，git会先自动合并冲突，如果不能自动合并，就必需我们手动去处理冲突。 从服务器上pull代码到本地 如果本地没有.git目录，需要先初始化一下。 命令:git pull [远程服务器地址] [远程的分支] gh-pages分支-搭建博客. 需要把自已博客的网页代码上传到github上的gh-pages分支 然后就直接访问了 访问的url形式: [github用户名].github.io/[仓库的名字]/[具体的页面] sourceTree , tortoiseGitnpm 官网[https://www.npmjs.com] node package manager 命令: 初始化:npm init 安装指定包:npm install jquery --save 安装指定包:npm install jquery@版本号 --save 删除指定包:npm remove jquery --save 下载安装package.json中dependencies属性对的文件:npm install --production browser-sync 更改代码之后自动刷新浏览器 需要使用npm进行全局安装:npm install browser-sync -g,-g表示安装到全局 使用:browser-sync start --server --files &quot;./index.html,app.css,./css/*.css,*.*&quot; ``z注意这里父文件和子文件都不要用中文 后面指定文件用双引号 –files参数指定要监视的文件，后面跟要监视的文件的文件路径以逗号分隔。 gulp 官网 中文网 前端自动化构建工具js压缩,var x,xname，混淆合并.css压缩html压压缩 grunt ,webpack… 核心就5个方法 task,gulp中是一个个任务的形式来实现功能。 task(‘任务名’,function(){…..}); src src(‘./*.js’) dest(‘./minjs/‘)// 指定处理后的文件的输出路径. watch(‘./*.js’,[‘任务名1’,’任务名2’]); run(‘任务名’);//执行指定的任务. gulp的安装 使用npm 进行安装 npm install gulp-cli -g; gulp 使用使用时还需要在项目中通过npm非全局安装gulp npm install gulp --save-dev 还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.gulp的一些插件 也是使用npm安装 对js代码进行压缩 gulp-uglify 对代码进行合并 gulp-concat 对css进行压缩 gulp-cssnano 对html进行压缩 gulp-htmlmin","categories":[],"tags":[],"keywords":[]},{"title":"git总结","slug":"git初识","date":"2017-02-18T06:41:33.000Z","updated":"2017-02-18T06:41:33.000Z","comments":true,"path":"2017/02/18/git初识/","link":"","permalink":"http://yoursite.com/2017/02/18/git初识/","excerpt":"","text":"Git什么是Git? Git是一款源代码管理工具(版本控制工具) 我们写的代码需要使用Git进行管理。1.0是稳定2.0加了新功能 源代码有必要管理起吗？ 有必要，因为人工的去处理不同的版本，做相应备份会很麻烦。 svn,vss,vcs,tfs…..-Git是linux之父当年为了维护linux—linus之前也是手动维护合并把文件发给Linus BitKeeper(收费) 有人想破解(不给提供免费使用) linus自己写了一个版本管理的工具（Git） 分布式版本管理工具，集中式 git属于分布式 svn集中式 git安装git初始化一个仓库 其实就是创建了一个.git隐藏目录 命令:git init; 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令. 一般是在项目的根目录执行这个命令. 自报家门 配置用户名 : git config user.name &quot;testName&quot; 配置全局用户名 : git config --global user.name &quot;testName&quot; 配置邮箱 : git config user.email &quot;test@sina.com&quot; 配置邮箱 : git config --global user.email &quot;test@sina.com&quot; 查看配置信息: git config --list 把代码提交到仓库中 1.先把代码添加到暂存区(就相当于放到仓库门口) 命令:git add 文件路径/文件名 示例:git add ./reademe.md 可以使用git add .这个命令，批量把当前目录下所有修改过的文件添加到暂存区。 2.把暂存区的文件提交仓库里 命令: git commit -m &quot;注释&quot; 示例: git commit -m &quot;我们添加了一个新的功能&quot; -m 表示指定一个字符串，作为提交的说明(相当于注释); 合并add 与commit 命令 git commit -a -m &quot;这是使用合并添加与提交的操作&quot;; 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用) 查看工作区状态 命令:git status 添加忽略文件 在项目中有一些文件是不需要提交的,我们需要把它忽略掉 需要在.git文件夹所在目录新建一个名为.gitignore的文件然后在这个文件中写上需要被忽略的文件的路径。示例: /css/a.css: /css/*.css : /a.html 比对文件差异 命令: git diff 用来比较暂存区文件内容与工作区文件内容的区别 如果暂存区没有文件，就会将工作与代码与最近一次提交对比 命令：git diff --cached 比较暂存区的文件和仓库中文件的区别 对比之前某两次提交的文件的差异 命令:git diff [版本号1] [版本号2] [想比较的文件路径] 查看日志 命令:git log,可以查看每一次提交的日志 命令:git log --oneline 表示使用简洁的形式输出提交日志 版本回退 命令:git reset --hard Head~1 这是将代码回退到上上一次提交时的状态 命令:git reset --hard Head~2 回退到上上上次 命令:git reset --hard Head~0 回退到上次提交时的状态,~0可以省略 命令:git reset --hard 版本号 通过每次提交时生成的版本号来回退版本 通过git reflog命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。 创建分支 命令:git branch [分支名] 创建一个新分支 命令:git branch 查看当前所有的分支 切换分支 命令:git checkout [分支名] 切换分支后可以在切换后的分支中进行正常的操作 合并分支 命令:git merge [分支名] git会将指定的分支合并到当前分支. 删除分支 命令:git branch -d [分支名] 删除指定分支，-d参数表示要执行删除操作 git提交中的冲突 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交 githubgithub与git git 版本管理工具 github 就是一个网站，只是这个网站提供git服务器的功能 上传代码到git服务器(push) 命令:git push [远程服务器地址] [远程服务器的分支] 示例:git push https://github.com/huoqishi/test002.git master 上传时可以使用一些简化的命令 将远程服务器地址写成变量的形式 git remote add [变量名] [远程服务器地址] 示例:git remote add origin https://github.com/huoqishi/test002.git 这样之后就可以直接使用origin来代替git push 后面写的地址了git push origin master 还可以尽一步简化 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了git push origin;","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2017-02-18T05:57:42.000Z","updated":"2017-02-18T05:57:42.000Z","comments":true,"path":"2017/02/18/hello-world/","link":"","permalink":"http://yoursite.com/2017/02/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"正则表达式","date":"2017-02-12T15:11:44.000Z","updated":"2017-02-12T15:11:44.000Z","comments":true,"path":"2017/02/12/正则表达式/","link":"","permalink":"http://yoursite.com/2017/02/12/正则表达式/","excerpt":"","text":"##正则表达式 ####RegExp对象创建的方法 new RegExp(&quot;a&quot;,&quot;i&quot;); //后面的i就是忽略字母大小写。 /a/i //后面的i就是忽略字母大小写。 g全局 +0个或者多个 | 或者 [a,b,c] a或者b或者c [0-9]数字 [a-z]字符 [0-9a-z]数字字符 [^a]除了a + 1个或者多个 ？0个或者1个 *0或者多个 \\转移符","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"less使用","date":"2017-02-10T02:55:16.000Z","updated":"2017-02-10T02:55:16.000Z","comments":true,"path":"2017/02/10/less使用/","link":"","permalink":"http://yoursite.com/2017/02/10/less使用/","excerpt":"","text":"##less语法 ####一、注释的区别 /**/会编译在css文件中 //不会编译在css中 ####二、声明变量及使用 @maincolor:#92322; 使用变量 body{ color:@maincolor;} ####三、mixin混入 .redFont{ color:red; } .redBorder { border:1px solid red; } //红色文字和边框 通过class混合 .redFontBorder-class { .redFont(); .redBOrder(); } //方法 .redFont-func(){ color:red; } .redBorder-func(){ border:1px solid red; } //红色文字和边框 通过func混合 .redFontBorder-func{ .redFont-func(); .redBorder-func(); } ####四、嵌套 #header{ width:100px; &gt;div{ width:100px; p{ width:100px; &amp;:hover { width:100px; } } &amp;+div { width:100px; } //&amp;~div { width:100px; } } } 直接写在里面就是 后代选择器 &amp;：hover &gt; 子代选择器 &amp;+ 加号选择器 &amp;~ 波浪选择器 ####五、导入@import 注意这里引入less文件的时候不用加后缀名 如: @import “文件名”； 可以使用引入文件的变量和函数以及类名。 ####六、运算 颜色运算 @red:red*0.5; 内置函数 @gary:darken(#333,10%); ####七、less的使用 引用less文件 注意在引用的时候文件类型写type/less 引用less.js文件(在浏览器上使用less，我们需要添加一个js插件 less.js 解析less文件动态加载 注意：他是一部加载less文件 然后解析 一定要求是 使用http形式访问 否则无法加载less文件 不建议使用less.js这种形式来用less","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"art-template的模板引擎","date":"2017-01-06T00:46:07.000Z","updated":"2017-01-06T00:46:07.000Z","comments":true,"path":"2017/01/06/art-template的模板引擎/","link":"","permalink":"http://yoursite.com/2017/01/06/art-template的模板引擎/","excerpt":"","text":"#####jQuery遍历对象 $.each(data,function(i,e){e.attr})； attr就是对象的属性。 例如：$.each(data,function(i,e){ var date = new Date(Number(e.time+’000’)).toLocaleString(); infomation += ‘‘+ e.desc +’‘+ date +’‘; }) ####artTemplate方法一 &lt;!DOCTYPE HTML&gt; basic-demo &lt;body&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt; {{if isAdmin}} &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;ul&gt; {{each list as value i}} &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt; {{/each}} &lt;/ul&gt; {{/if}} &lt;/script&gt; &lt;script&gt; var data = { title: &apos;基本例子&apos;, isAdmin: true, list: [&apos;文艺&apos;, &apos;博客&apos;, &apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;] }; var html = template(&apos;test&apos;, data); document.getElementById(&apos;content&apos;).innerHTML = html; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ####artTemplate方法二 &lt;!DOCTYPE HTML&gt; compile-demo &lt;body&gt; &lt;h1&gt;在javascript中存放模板&lt;/h1&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script&gt; var source = &apos;&lt;ul&gt;&apos; + &apos;{{each list as value i}}&apos; + &apos;&lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;&apos; + &apos;{{/each}}&apos; + &apos;&lt;/ul&gt;&apos;; var render = template.compile(source); var data = { list: [&apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;] }; var html = render(data); document.getElementById(&apos;content&apos;).innerHTML = html; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ####artTemplate方法三-嵌入子模板 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;include-demo&lt;/title&gt; &lt;script src=&quot;../dist/template.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; {{include 'list'}} &lt;/script&gt; &lt;script id=&quot;list&quot; type=&quot;text/html&quot;&gt; &lt;ul&gt; {{each list as value i}} &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt; {{/each}} &lt;/ul&gt; &lt;/script&gt; &lt;script&gt; var data = { title: &apos;嵌入子模板&apos;, list: [&apos;文艺&apos;, &apos;博客&apos;, &apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;] }; var html = template(&apos;test&apos;, data); document.getElementById(&apos;content&apos;).innerHTML = html; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ####注意点 {{each list as value i}} list可以为对象或者是数组，value为值，i为索引。 ####把获取到的时间转换为现在的时间 var data = new Date(Number(e.time+”000”)).toLocaleString(); 因为从后台传回来的是json格式的字符串，并且new Date().toLocaleString();里面必须为数字。所以用Number强制转换为数字。","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"字符串方法","date":"2016-12-26T00:59:17.000Z","updated":"2016-12-26T00:59:17.000Z","comments":true,"path":"2016/12/26/字符串方法/","link":"","permalink":"http://yoursite.com/2016/12/26/字符串方法/","excerpt":"","text":"1，获取字符串长度Length属性string.length2，连接字符串：concats1.concat(1,2,3);3,获取索引值：indexOf()string.indexof(“v”)string.indexof(“v”,fromIndex)如果没有就返回-1表示从索引位置fromIndex开始查找，如果fromIndex省略，则表示默认从起始索引0开始查找若fromIndex为负，则从索引0开始查找.4,根据索引值获取单个字符：charAt()5,substr(fromIndex,length)获取部分字符串从起始索引fromIndex开始截取长度length的字符串6,substring(startIndex,endIndex)获取部分字符串截取 起始索引startIndex 到 结束索引endIndex的子字符串，结果包含startIndex处的字符，不包含endIndex处的字符。7,slice(startIndex,endIndex)获取部分字符串截取 起始索引startIndex 到 结束索引endIndex的子字符串，结果包含startIndex处的字符，不包含endIndex处的字符。8,split()分割按给定字符串分割，返回分割后的多个字符串组成的字符串数组。9,Join()合并使用您选择的分隔符将一个数组合并为一个字符串10,toLowerCase()转小写toUpperCase()转大写字符串大小写转换使用您选择的分隔符将一个数组合并为一个字符串","categories":[],"tags":[],"keywords":[]}]}